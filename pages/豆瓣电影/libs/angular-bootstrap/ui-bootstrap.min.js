/*
 * angular-ui-bootstrap
 * http://angular-ui.github.io/bootstrap/

 * Version: 1.1.1 - 2016-01-25
 * License: MIT
 */angular.module('ui.bootstrap', ['ui.bootstrap.collapse', 'ui.bootstrap.accordion', 'ui.bootstrap.alert', 'ui.bootstrap.buttons', 'ui.bootstrap.carousel', 'ui.bootstrap.dateparser', 'ui.bootstrap.isClass', 'ui.bootstrap.position', 'ui.bootstrap.datepicker', 'ui.bootstrap.debounce', 'ui.bootstrap.dropdown', 'ui.bootstrap.stackedMap', 'ui.bootstrap.modal', 'ui.bootstrap.paging', 'ui.bootstrap.pager', 'ui.bootstrap.pagination', 'ui.bootstrap.tooltip', 'ui.bootstrap.popover', 'ui.bootstrap.progressbar', 'ui.bootstrap.rating', 'ui.bootstrap.tabs', 'ui.bootstrap.timepicker', 'ui.bootstrap.typeahead']), angular.module('ui.bootstrap.collapse', []).directive('uibCollapse', ['$animate', '$q', '$parse', '$injector', function (a, b, c, d) {
  const e = d.has('$animateCss') ? d.get('$animateCss') : null; return {
    link(d, f, g) {
      function h() { f.hasClass('collapse') && f.hasClass('in') || b.resolve(l(d)).then(() => { f.removeClass('collapse').addClass('collapsing').attr('aria-expanded', !0).attr('aria-hidden', !1), e ? e(f, { addClass: 'in', easing: 'ease', to: { height: `${f[0].scrollHeight}px` } }).start().finally(i) : a.addClass(f, 'in', { to: { height: `${f[0].scrollHeight}px` } }).then(i); }); } function i() { f.removeClass('collapsing').addClass('collapse').css({ height: 'auto' }), m(d); } function j() {
        return f.hasClass('collapse') || f.hasClass('in') ? void b.resolve(n(d)).then(() => {
          f.css({ height: `${f[0].scrollHeight}px` }).removeClass('collapse').addClass('collapsing').attr('aria-expanded', !1)
            .attr('aria-hidden', !0), e ? e(f, { removeClass: 'in', to: { height: '0' } }).start().finally(k) : a.removeClass(f, 'in', { to: { height: '0' } }).then(k);
        }) : k();
      } function k() { f.css({ height: '0' }), f.removeClass('collapsing').addClass('collapse'), o(d); } var l = c(g.expanding); var m = c(g.expanded); var n = c(g.collapsing); var o = c(g.collapsed); d.$eval(g.uibCollapse) || f.addClass('in').addClass('collapse').attr('aria-expanded', !0).attr('aria-hidden', !1)
        .css({ height: 'auto' }), d.$watch(g.uibCollapse, (a) => { a ? j() : h(); });
    },
  };
}]), angular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse']).constant('uibAccordionConfig', { closeOthers: !0 }).controller('UibAccordionController', ['$scope', '$attrs', 'uibAccordionConfig', function (a, b, c) { this.groups = [], this.closeOthers = function (d) { const e = angular.isDefined(b.closeOthers) ? a.$eval(b.closeOthers) : c.closeOthers; e && angular.forEach(this.groups, (a) => { a !== d && (a.isOpen = !1); }); }, this.addGroup = function (a) { const b = this; this.groups.push(a), a.$on('$destroy', (c) => { b.removeGroup(a); }); }, this.removeGroup = function (a) { const b = this.groups.indexOf(a); b !== -1 && this.groups.splice(b, 1); }; }]).directive('uibAccordion', () => ({
  controller: 'UibAccordionController', controllerAs: 'accordion', transclude: !0, templateUrl(a, b) { return b.templateUrl || 'uib/template/accordion/accordion.html'; },
}))
  .directive('uibAccordionGroup', () => ({
    require: '^uibAccordion', transclude: !0, replace: !0, templateUrl(a, b) { return b.templateUrl || 'uib/template/accordion/accordion-group.html'; }, scope: { heading: '@', isOpen: '=?', isDisabled: '=?' }, controller() { this.setHeading = function (a) { this.heading = a; }; }, link(a, b, c, d) { d.addGroup(a), a.openClass = c.openClass || 'panel-open', a.panelClass = c.panelClass || 'panel-default', a.$watch('isOpen', (c) => { b.toggleClass(a.openClass, !!c), c && d.closeOthers(a); }), a.toggleOpen = function (b) { a.isDisabled || b && b.which !== 32 || (a.isOpen = !a.isOpen); }; },
  }))
  .directive('uibAccordionHeading', () => ({
    transclude: !0, template: '', replace: !0, require: '^uibAccordionGroup', link(a, b, c, d, e) { d.setHeading(e(a, angular.noop)); },
  }))
  .directive('uibAccordionTransclude', () => ({ require: '^uibAccordionGroup', link(a, b, c, d) { a.$watch(() => d[c.uibAccordionTransclude], (a) => { a && (b.find('span').html(''), b.find('span').append(a)); }); } })), angular.module('ui.bootstrap.alert', []).controller('UibAlertController', ['$scope', '$attrs', '$interpolate', '$timeout', function (a, b, c, d) { a.closeable = !!b.close; const e = angular.isDefined(b.dismissOnTimeout) ? c(b.dismissOnTimeout)(a.$parent) : null; e && d(() => { a.close(); }, parseInt(e, 10)); }]).directive('uibAlert', () => ({
  controller: 'UibAlertController', controllerAs: 'alert', templateUrl(a, b) { return b.templateUrl || 'uib/template/alert/alert.html'; }, transclude: !0, replace: !0, scope: { type: '@', close: '&' },
})), angular.module('ui.bootstrap.buttons', []).constant('uibButtonConfig', { activeClass: 'active', toggleEvent: 'click' }).controller('UibButtonsController', ['uibButtonConfig', function (a) { this.activeClass = a.activeClass || 'active', this.toggleEvent = a.toggleEvent || 'click'; }]).directive('uibBtnRadio', ['$parse', function (a) {
  return {
    require: ['uibBtnRadio', 'ngModel'], controller: 'UibButtonsController', controllerAs: 'buttons', link(b, c, d, e) { const f = e[0]; const g = e[1]; const h = a(d.uibUncheckable); c.find('input').css({ display: 'none' }), g.$render = function () { c.toggleClass(f.activeClass, angular.equals(g.$modelValue, b.$eval(d.uibBtnRadio))); }, c.on(f.toggleEvent, () => { if (!d.disabled) { const a = c.hasClass(f.activeClass); (!a || angular.isDefined(d.uncheckable)) && b.$apply(() => { g.$setViewValue(a ? null : b.$eval(d.uibBtnRadio)), g.$render(); }); } }), d.uibUncheckable && b.$watch(h, (a) => { d.$set('uncheckable', a ? '' : null); }); },
  };
}])
  .directive('uibBtnCheckbox', () => ({
    require: ['uibBtnCheckbox', 'ngModel'], controller: 'UibButtonsController', controllerAs: 'button', link(a, b, c, d) { function e() { return g(c.btnCheckboxTrue, !0); } function f() { return g(c.btnCheckboxFalse, !1); } function g(b, c) { return angular.isDefined(b) ? a.$eval(b) : c; } const h = d[0]; const i = d[1]; b.find('input').css({ display: 'none' }), i.$render = function () { b.toggleClass(h.activeClass, angular.equals(i.$modelValue, e())); }, b.on(h.toggleEvent, () => { c.disabled || a.$apply(() => { i.$setViewValue(b.hasClass(h.activeClass) ? f() : e()), i.$render(); }); }); },
  })), angular.module('ui.bootstrap.carousel', []).controller('UibCarouselController', ['$scope', '$element', '$interval', '$timeout', '$animate', function (a, b, c, d, e) { function f() { for (;s.length;)s.shift(); } function g(a) { if (angular.isUndefined(p[a].index)) return p[a]; for (let b = 0, c = p.length; c > b; ++b) if (p[b].index === a) return p[b]; } function h(c, d, g) { t || (angular.extend(c, { direction: g, active: !0 }), angular.extend(o.currentSlide || {}, { direction: g, active: !1 }), e.enabled(b) && !a.$currentTransition && c.$element && o.slides.length > 1 && (c.$element.data(q, c.direction), o.currentSlide && o.currentSlide.$element && o.currentSlide.$element.data(q, c.direction), a.$currentTransition = !0, e.on('addClass', c.$element, (b, c) => { if (c === 'close' && (a.$currentTransition = null, e.off('addClass', b), s.length)) { const d = s.pop(); const g = a.indexOfSlide(d); const i = g > o.getCurrentIndex() ? 'next' : 'prev'; f(), h(d, g, i); } })), o.currentSlide = c, r = d, k()); } function i() { m && (c.cancel(m), m = null); } function j(b) { b.length || (a.$currentTransition = null, f()); } function k() { i(); const b = +a.interval; !isNaN(b) && b > 0 && (m = c(l, b)); } function l() { const b = +a.interval; n && !isNaN(b) && b > 0 && p.length ? a.next() : a.pause(); } let m; let n; var o = this; var p = o.slides = a.slides = []; var q = 'uib-slideDirection'; var r = -1; var s = []; o.currentSlide = null; var t = !1; o.addSlide = function (b, c) { b.$element = c, p.push(b), p.length === 1 || b.active ? (a.$currentTransition && (a.$currentTransition = null), o.select(p[p.length - 1]), p.length === 1 && a.play()) : b.active = !1; }, o.getCurrentIndex = function () { return o.currentSlide && angular.isDefined(o.currentSlide.index) ? +o.currentSlide.index : r; }, o.next = a.next = function () { const b = (o.getCurrentIndex() + 1) % p.length; return b === 0 && a.noWrap() ? void a.pause() : o.select(g(b), 'next'); }, o.prev = a.prev = function () { const b = o.getCurrentIndex() - 1 < 0 ? p.length - 1 : o.getCurrentIndex() - 1; return a.noWrap() && b === p.length - 1 ? void a.pause() : o.select(g(b), 'prev'); }, o.removeSlide = function (a) { angular.isDefined(a.index) && p.sort((a, b) => +a.index > +b.index); const b = s.indexOf(a); b !== -1 && s.splice(b, 1); const c = p.indexOf(a); p.splice(c, 1), d(() => { p.length > 0 && a.active ? c >= p.length ? o.select(p[c - 1]) : o.select(p[c]) : r > c && r--; }), p.length === 0 && (o.currentSlide = null, f()); }, o.select = a.select = function (b, c) { const d = a.indexOfSlide(b); void 0 === c && (c = d > o.getCurrentIndex() ? 'next' : 'prev'), b && b !== o.currentSlide && !a.$currentTransition ? h(b, d, c) : b && b !== o.currentSlide && a.$currentTransition && (s.push(b), b.active = !1); }, a.indexOfSlide = function (a) { return angular.isDefined(a.index) ? +a.index : p.indexOf(a); }, a.isActive = function (a) { return o.currentSlide === a; }, a.pause = function () { a.noPause || (n = !1, i()); }, a.play = function () { n || (n = !0, k()); }, a.$on('$destroy', () => { t = !0, i(); }), a.$watch('noTransition', (a) => { e.enabled(b, !a); }), a.$watch('interval', k), a.$watchCollection('slides', j); }]).directive('uibCarousel', () => ({
  transclude: !0,
  replace: !0,
  controller: 'UibCarouselController',
  controllerAs: 'carousel',
  templateUrl(a, b) { return b.templateUrl || 'uib/template/carousel/carousel.html'; },
  scope: {
    interval: '=', noTransition: '=', noPause: '=', noWrap: '&',
  },
})).directive('uibSlide', () => ({
  require: '^uibCarousel', transclude: !0, replace: !0, templateUrl(a, b) { return b.templateUrl || 'uib/template/carousel/slide.html'; }, scope: { active: '=?', actual: '=?', index: '=?' }, link(a, b, c, d) { d.addSlide(a, b), a.$on('$destroy', () => { d.removeSlide(a); }), a.$watch('active', (b) => { b && d.select(a); }); },
}))
  .animation('.item', ['$animateCss', function (a) { function b(a, b, c) { a.removeClass(b), c && c(); } const c = 'uib-slideDirection'; return { beforeAddClass(d, e, f) { if (e === 'active') { let g = !1; const h = d.data(c); const i = h === 'next' ? 'left' : 'right'; const j = b.bind(this, d, `${i} ${h}`, f); return d.addClass(h), a(d, { addClass: i }).start().done(j), function () { g = !0; }; }f(); }, beforeRemoveClass(d, e, f) { if (e === 'active') { let g = !1; const h = d.data(c); const i = h === 'next' ? 'left' : 'right'; const j = b.bind(this, d, i, f); return a(d, { addClass: i }).start().done(j), function () { g = !0; }; }f(); } }; }]), angular.module('ui.bootstrap.dateparser', []).service('uibDateParser', ['$log', '$locale', 'orderByFilter', function (a, b, c) {
  function d(a) { const b = []; const d = a.split(''); const e = a.indexOf("'"); if (e > -1) { let f = !1; a = a.split(''); for (let g = e; g < a.length; g++)f ? (a[g] === "'" && (g + 1 < a.length && a[g + 1] === "'" ? (a[g + 1] = '$', d[g + 1] = '') : (d[g] = '', f = !1)), a[g] = '$') : a[g] === "'" && (a[g] = '$', d[g] = '', f = !0); a = a.join(''); } return angular.forEach(m, (c) => { const e = a.indexOf(c.key); if (e > -1) { a = a.split(''), d[e] = `(${c.regex})`, a[e] = '$'; for (let f = e + 1, g = e + c.key.length; g > f; f++)d[f] = '', a[f] = '$'; a = a.join(''), b.push({ index: e, apply: c.apply, matcher: c.regex }); } }), { regex: new RegExp(`^${d.join('')}$`), map: c(b, 'index') }; } function e(a, b, c) { return c < 1 ? !1 : b === 1 && c > 28 ? c === 29 && (a % 4 === 0 && a % 100 !== 0 || a % 400 === 0) : b === 3 || b === 5 || b === 8 || b === 10 ? c < 31 : !0; } function f(a) { return parseInt(a, 10); } function g(a, b) { return a && b ? k(a, b) : a; } function h(a, b) { return a && b ? k(a, b, !0) : a; } function i(a, b) { const c = Date.parse(`Jan 01, 1970 00:00:00 ${a}`) / 6e4; return isNaN(c) ? b : c; } function j(a, b) { return a = new Date(a.getTime()), a.setMinutes(a.getMinutes() + b), a; } function k(a, b, c) { c = c ? -1 : 1; const d = i(b, a.getTimezoneOffset()); return j(a, c * (d - a.getTimezoneOffset())); } let l; let m; const n = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g; this.init = function () { l = b.id, this.parsers = {}, m = [{ key: 'yyyy', regex: '\\d{4}', apply(a) { this.year = +a; } }, { key: 'yy', regex: '\\d{2}', apply(a) { this.year = +a + 2e3; } }, { key: 'y', regex: '\\d{1,4}', apply(a) { this.year = +a; } }, { key: 'M!', regex: '0?[1-9]|1[0-2]', apply(a) { this.month = a - 1; } }, { key: 'MMMM', regex: b.DATETIME_FORMATS.MONTH.join('|'), apply(a) { this.month = b.DATETIME_FORMATS.MONTH.indexOf(a); } }, { key: 'MMM', regex: b.DATETIME_FORMATS.SHORTMONTH.join('|'), apply(a) { this.month = b.DATETIME_FORMATS.SHORTMONTH.indexOf(a); } }, { key: 'MM', regex: '0[1-9]|1[0-2]', apply(a) { this.month = a - 1; } }, { key: 'M', regex: '[1-9]|1[0-2]', apply(a) { this.month = a - 1; } }, { key: 'd!', regex: '[0-2]?[0-9]{1}|3[0-1]{1}', apply(a) { this.date = +a; } }, { key: 'dd', regex: '[0-2][0-9]{1}|3[0-1]{1}', apply(a) { this.date = +a; } }, { key: 'd', regex: '[1-2]?[0-9]{1}|3[0-1]{1}', apply(a) { this.date = +a; } }, { key: 'EEEE', regex: b.DATETIME_FORMATS.DAY.join('|') }, { key: 'EEE', regex: b.DATETIME_FORMATS.SHORTDAY.join('|') }, { key: 'HH', regex: '(?:0|1)[0-9]|2[0-3]', apply(a) { this.hours = +a; } }, { key: 'hh', regex: '0[0-9]|1[0-2]', apply(a) { this.hours = +a; } }, { key: 'H', regex: '1?[0-9]|2[0-3]', apply(a) { this.hours = +a; } }, { key: 'h', regex: '[0-9]|1[0-2]', apply(a) { this.hours = +a; } }, { key: 'mm', regex: '[0-5][0-9]', apply(a) { this.minutes = +a; } }, { key: 'm', regex: '[0-9]|[1-5][0-9]', apply(a) { this.minutes = +a; } }, { key: 'sss', regex: '[0-9][0-9][0-9]', apply(a) { this.milliseconds = +a; } }, { key: 'ss', regex: '[0-5][0-9]', apply(a) { this.seconds = +a; } }, { key: 's', regex: '[0-9]|[1-5][0-9]', apply(a) { this.seconds = +a; } }, { key: 'a', regex: b.DATETIME_FORMATS.AMPMS.join('|'), apply(a) { this.hours === 12 && (this.hours = 0), a === 'PM' && (this.hours += 12); } }, { key: 'Z', regex: '[+-]\\d{4}', apply(a) { const b = a.match(/([+-])(\d{2})(\d{2})/); const c = b[1]; const d = b[2]; const e = b[3]; this.hours += f(c + d), this.minutes += f(c + e); } }, { key: 'ww', regex: '[0-4][0-9]|5[0-3]' }, { key: 'w', regex: '[0-9]|[1-4][0-9]|5[0-3]' }, { key: 'GGGG', regex: b.DATETIME_FORMATS.ERANAMES.join('|').replace(/\s/g, '\\s') }, { key: 'GGG', regex: b.DATETIME_FORMATS.ERAS.join('|') }, { key: 'GG', regex: b.DATETIME_FORMATS.ERAS.join('|') }, { key: 'G', regex: b.DATETIME_FORMATS.ERAS.join('|') }]; }, this.init(), this.parse = function (c, f, g) {
    if (!angular.isString(c) || !f) return c; f = b.DATETIME_FORMATS[f] || f, f = f.replace(n, '\\$&'), b.id !== l && this.init(), this.parsers[f] || (this.parsers[f] = d(f)); const h = this.parsers[f]; const i = h.regex; const j = h.map; const k = c.match(i); let m = !1; if (k && k.length) {
      let o; let p; angular.isDate(g) && !isNaN(g.getTime()) ? o = {
        year: g.getFullYear(), month: g.getMonth(), date: g.getDate(), hours: g.getHours(), minutes: g.getMinutes(), seconds: g.getSeconds(), milliseconds: g.getMilliseconds(),
      } : (g && a.warn('dateparser:', 'baseDate is not a valid date'), o = {
        year: 1900, month: 0, date: 1, hours: 0, minutes: 0, seconds: 0, milliseconds: 0,
      }); for (let q = 1, r = k.length; r > q; q++) { const s = j[q - 1]; s.matcher === 'Z' && (m = !0), s.apply && s.apply.call(o, k[q]); } const t = m ? Date.prototype.setUTCFullYear : Date.prototype.setFullYear; const u = m ? Date.prototype.setUTCHours : Date.prototype.setHours; return e(o.year, o.month, o.date) && (!angular.isDate(g) || isNaN(g.getTime()) || m ? (p = new Date(0), t.call(p, o.year, o.month, o.date), u.call(p, o.hours || 0, o.minutes || 0, o.seconds || 0, o.milliseconds || 0)) : (p = new Date(g), t.call(p, o.year, o.month, o.date), u.call(p, o.hours, o.minutes, o.seconds, o.milliseconds))), p;
    }
  }, this.toTimezone = g, this.fromTimezone = h, this.timezoneToOffset = i, this.addDateMinutes = j, this.convertTimezoneToLocal = k;
}]), angular.module('ui.bootstrap.isClass', []).directive('uibIsClass', ['$animate', function (a) {
  const b = /^\s*([\s\S]+?)\s+on\s+([\s\S]+?)\s*$/; const c = /^\s*([\s\S]+?)\s+for\s+([\s\S]+?)\s*$/; return {
    restrict: 'A',
    compile(d, e) {
      function f(a, b, c) { i.push(a), j.push({ scope: a, element: b }), o.forEach((b, c) => { g(b, a); }), a.$on('$destroy', h); } function g(b, d) {
        const e = b.match(c); const f = d.$eval(e[1]); const g = e[2]; let h = k[b]; if (!h) {
          const i = function (b) { let c = null; j.some((a) => { const d = a.scope.$eval(m); return d === b ? (c = a, !0) : void 0; }), h.lastActivated !== c && (h.lastActivated && a.removeClass(h.lastActivated.element, f), c && a.addClass(c.element, f), h.lastActivated = c); }; k[b] = h = {
            lastActivated: null, scope: d, watchFn: i, compareWithExp: g, watcher: d.$watch(g, i),
          };
        }h.watchFn(d.$eval(g));
      } function h(a) { const b = a.targetScope; const c = i.indexOf(b); if (i.splice(c, 1), j.splice(c, 1), i.length) { const d = i[0]; angular.forEach(k, (a) => { a.scope === b && (a.watcher = d.$watch(a.compareWithExp, a.watchFn), a.scope = d); }); } else k = {}; } var i = []; var j = []; var k = {}; const l = e.uibIsClass.match(b); var m = l[2]; const n = l[1]; var o = n.split(','); return f;
    },
  };
}]), angular.module('ui.bootstrap.position', []).factory('$uibPosition', ['$document', '$window', function (a, b) {
  let c; const d = { normal: /(auto|scroll)/, hidden: /(auto|scroll|hidden)/ }; const e = {
    auto: /\s?auto?\s?/i, primary: /^(top|bottom|left|right)$/, secondary: /^(top|bottom|left|right|center)$/, vertical: /^(top|bottom)$/,
  }; return {
    getRawNode(a) { return a[0] || a; },
    parseStyle(a) { return a = parseFloat(a), isFinite(a) ? a : 0; },
    offsetParent(c) { function d(a) { return (b.getComputedStyle(a).position || 'static') === 'static'; }c = this.getRawNode(c); for (var e = c.offsetParent || a[0].documentElement; e && e !== a[0].documentElement && d(e);)e = e.offsetParent; return e || a[0].documentElement; },
    scrollbarWidth() { if (angular.isUndefined(c)) { const b = angular.element('<div style="position: absolute; top: -9999px; width: 50px; height: 50px; overflow: scroll;"></div>'); a.find('body').append(b), c = b[0].offsetWidth - b[0].clientWidth, c = isFinite(c) ? c : 0, b.remove(); } return c; },
    scrollParent(c, e) { c = this.getRawNode(c); const f = e ? d.hidden : d.normal; const g = a[0].documentElement; const h = b.getComputedStyle(c); let i = h.position === 'absolute'; let j = c.parentElement || g; if (j === g || h.position === 'fixed') return g; for (;j.parentElement && j !== g;) { const k = b.getComputedStyle(j); if (i && k.position !== 'static' && (i = !1), !i && f.test(k.overflow + k.overflowY + k.overflowX)) break; j = j.parentElement; } return j; },
    position(c, d) {
      c = this.getRawNode(c); const e = this.offset(c); if (d) { const f = b.getComputedStyle(c); e.top -= this.parseStyle(f.marginTop), e.left -= this.parseStyle(f.marginLeft); } const g = this.offsetParent(c); let h = { top: 0, left: 0 }; return g !== a[0].documentElement && (h = this.offset(g), h.top += g.clientTop - g.scrollTop, h.left += g.clientLeft - g.scrollLeft), {
        width: Math.round(angular.isNumber(e.width) ? e.width : c.offsetWidth), height: Math.round(angular.isNumber(e.height) ? e.height : c.offsetHeight), top: Math.round(e.top - h.top), left: Math.round(e.left - h.left),
      };
    },
    offset(c) {
      c = this.getRawNode(c); const d = c.getBoundingClientRect(); return {
        width: Math.round(angular.isNumber(d.width) ? d.width : c.offsetWidth), height: Math.round(angular.isNumber(d.height) ? d.height : c.offsetHeight), top: Math.round(d.top + (b.pageYOffset || a[0].documentElement.scrollTop)), left: Math.round(d.left + (b.pageXOffset || a[0].documentElement.scrollLeft)),
      };
    },
    viewportOffset(c, d, e) {
      c = this.getRawNode(c), e = e !== !1 ? !0 : !1; const f = c.getBoundingClientRect(); const g = {
        top: 0, left: 0, bottom: 0, right: 0,
      }; const h = d ? a[0].documentElement : this.scrollParent(c); const i = h.getBoundingClientRect(); if (g.top = i.top + h.clientTop, g.left = i.left + h.clientLeft, h === a[0].documentElement && (g.top += b.pageYOffset, g.left += b.pageXOffset), g.bottom = g.top + h.clientHeight, g.right = g.left + h.clientWidth, e) { const j = b.getComputedStyle(h); g.top += this.parseStyle(j.paddingTop), g.bottom -= this.parseStyle(j.paddingBottom), g.left += this.parseStyle(j.paddingLeft), g.right -= this.parseStyle(j.paddingRight); } return {
        top: Math.round(f.top - g.top), bottom: Math.round(g.bottom - f.bottom), left: Math.round(f.left - g.left), right: Math.round(g.right - f.right),
      };
    },
    parsePlacement(a) { const b = e.auto.test(a); return b && (a = a.replace(e.auto, '')), a = a.split('-'), a[0] = a[0] || 'top', e.primary.test(a[0]) || (a[0] = 'top'), a[1] = a[1] || 'center', e.secondary.test(a[1]) || (a[1] = 'center'), b ? a[2] = !0 : a[2] = !1, a; },
    positionElements(a, c, d, f) { a = this.getRawNode(a), c = this.getRawNode(c); const g = angular.isDefined(c.offsetWidth) ? c.offsetWidth : c.prop('offsetWidth'); const h = angular.isDefined(c.offsetHeight) ? c.offsetHeight : c.prop('offsetHeight'); d = this.parsePlacement(d); const i = f ? this.offset(a) : this.position(a); const j = { top: 0, left: 0, placement: '' }; if (d[2]) { const k = this.viewportOffset(a); const l = b.getComputedStyle(c); const m = { width: g + Math.round(Math.abs(this.parseStyle(l.marginLeft) + this.parseStyle(l.marginRight))), height: h + Math.round(Math.abs(this.parseStyle(l.marginTop) + this.parseStyle(l.marginBottom))) }; if (d[0] = d[0] === 'top' && m.height > k.top && m.height <= k.bottom ? 'bottom' : d[0] === 'bottom' && m.height > k.bottom && m.height <= k.top ? 'top' : d[0] === 'left' && m.width > k.left && m.width <= k.right ? 'right' : d[0] === 'right' && m.width > k.right && m.width <= k.left ? 'left' : d[0], d[1] = d[1] === 'top' && m.height - i.height > k.bottom && m.height - i.height <= k.top ? 'bottom' : d[1] === 'bottom' && m.height - i.height > k.top && m.height - i.height <= k.bottom ? 'top' : d[1] === 'left' && m.width - i.width > k.right && m.width - i.width <= k.left ? 'right' : d[1] === 'right' && m.width - i.width > k.left && m.width - i.width <= k.right ? 'left' : d[1], d[1] === 'center') if (e.vertical.test(d[0])) { const n = i.width / 2 - g / 2; k.left + n < 0 && m.width - i.width <= k.right ? d[1] = 'left' : k.right + n < 0 && m.width - i.width <= k.left && (d[1] = 'right'); } else { const o = i.height / 2 - m.height / 2; k.top + o < 0 && m.height - i.height <= k.bottom ? d[1] = 'top' : k.bottom + o < 0 && m.height - i.height <= k.top && (d[1] = 'bottom'); } } switch (d[0]) { case 'top': j.top = i.top - h; break; case 'bottom': j.top = i.top + i.height; break; case 'left': j.left = i.left - g; break; case 'right': j.left = i.left + i.width; } switch (d[1]) { case 'top': j.top = i.top; break; case 'bottom': j.top = i.top + i.height - h; break; case 'left': j.left = i.left; break; case 'right': j.left = i.left + i.width - g; break; case 'center': e.vertical.test(d[0]) ? j.left = i.left + i.width / 2 - g / 2 : j.top = i.top + i.height / 2 - h / 2; } return j.top = Math.round(j.top), j.left = Math.round(j.left), j.placement = d[1] === 'center' ? d[0] : `${d[0]}-${d[1]}`, j; },
    positionArrow(a, c) {
      a = this.getRawNode(a); const d = a.querySelector('.tooltip-inner, .popover-inner'); if (d) {
        const f = angular.element(d).hasClass('tooltip-inner'); const g = f ? a.querySelector('.tooltip-arrow') : a.querySelector('.arrow'); if (g) {
          if (c = this.parsePlacement(c), c[1] === 'center') {
            return void angular.element(g).css({
              top: '', bottom: '', right: '', left: '', margin: '',
            });
          } const h = `border-${c[0]}-width`; const i = b.getComputedStyle(g)[h]; let j = 'border-'; j += e.vertical.test(c[0]) ? `${c[0]}-${c[1]}` : `${c[1]}-${c[0]}`, j += '-radius'; const k = b.getComputedStyle(f ? d : a)[j]; const l = {
            top: 'auto', bottom: 'auto', left: 'auto', right: 'auto', margin: 0,
          }; switch (c[0]) { case 'top': l.bottom = f ? '0' : `-${i}`; break; case 'bottom': l.top = f ? '0' : `-${i}`; break; case 'left': l.right = f ? '0' : `-${i}`; break; case 'right': l.left = f ? '0' : `-${i}`; }l[c[1]] = k, angular.element(g).css(l);
        }
      }
    },
  };
}]), angular.module('ui.bootstrap.datepicker', ['ui.bootstrap.dateparser', 'ui.bootstrap.isClass', 'ui.bootstrap.position']).value('$datepickerSuppressError', !1).constant('uibDatepickerConfig', {
  datepickerMode: 'day', formatDay: 'dd', formatMonth: 'MMMM', formatYear: 'yyyy', formatDayHeader: 'EEE', formatDayTitle: 'MMMM yyyy', formatMonthTitle: 'yyyy', maxDate: null, maxMode: 'year', minDate: null, minMode: 'day', ngModelOptions: {}, shortcutPropagation: !1, showWeeks: !0, yearColumns: 5, yearRows: 4,
}).controller('UibDatepickerController', ['$scope', '$attrs', '$parse', '$interpolate', '$locale', '$log', 'dateFilter', 'uibDatepickerConfig', '$datepickerSuppressError', 'uibDateParser', function (a, b, c, d, e, f, g, h, i, j) {
  const k = this; let l = { $setViewValue: angular.noop }; let m = {}; const n = []; this.modes = ['day', 'month', 'year'], angular.forEach(['formatDay', 'formatMonth', 'formatYear', 'formatDayHeader', 'formatDayTitle', 'formatMonthTitle'], (c) => { k[c] = angular.isDefined(b[c]) ? d(b[c])(a.$parent) : h[c]; }), angular.forEach(['showWeeks', 'yearRows', 'yearColumns', 'shortcutPropagation'], (c) => { k[c] = angular.isDefined(b[c]) ? a.$parent.$eval(b[c]) : h[c]; }), angular.isDefined(b.startingDay) ? k.startingDay = a.$parent.$eval(b.startingDay) : angular.isNumber(h.startingDay) ? k.startingDay = h.startingDay : k.startingDay = (e.DATETIME_FORMATS.FIRSTDAYOFWEEK + 8) % 7, angular.forEach(['minDate', 'maxDate'], (c) => { b[c] ? n.push(a.$parent.$watch(b[c], (a) => { k[c] = a ? angular.isDate(a) ? j.fromTimezone(new Date(a), m.timezone) : new Date(g(a, 'medium')) : null, k.refreshView(); })) : k[c] = h[c] ? j.fromTimezone(new Date(h[c]), m.timezone) : null; }), angular.forEach(['minMode', 'maxMode'], (c) => { b[c] ? n.push(a.$parent.$watch(b[c], (d) => { k[c] = a[c] = angular.isDefined(d) ? d : b[c], (c === 'minMode' && k.modes.indexOf(a.datepickerMode) < k.modes.indexOf(k[c]) || c === 'maxMode' && k.modes.indexOf(a.datepickerMode) > k.modes.indexOf(k[c])) && (a.datepickerMode = k[c]); })) : k[c] = a[c] = h[c] || null; }), a.datepickerMode = a.datepickerMode || h.datepickerMode, a.uniqueId = `datepicker-${a.$id}-${Math.floor(1e4 * Math.random())}`, angular.isDefined(b.initDate) ? (this.activeDate = j.fromTimezone(a.$parent.$eval(b.initDate), m.timezone) || new Date(), n.push(a.$parent.$watch(b.initDate, (a) => { a && (l.$isEmpty(l.$modelValue) || l.$invalid) && (k.activeDate = j.fromTimezone(a, m.timezone), k.refreshView()); }))) : this.activeDate = new Date(), a.disabled = angular.isDefined(b.disabled) || !1, angular.isDefined(b.ngDisabled) && n.push(a.$parent.$watch(b.ngDisabled, (b) => { a.disabled = b, k.refreshView(); })), a.isActive = function (b) { return k.compare(b.date, k.activeDate) === 0 ? (a.activeDateId = b.uid, !0) : !1; }, this.init = function (a) { l = a, m = a.$options || h.ngModelOptions, l.$modelValue && (this.activeDate = l.$modelValue), l.$render = function () { k.render(); }; }, this.render = function () { if (l.$viewValue) { const a = new Date(l.$viewValue); const b = !isNaN(a); b ? this.activeDate = j.fromTimezone(a, m.timezone) : i || f.error('Datepicker directive: "ng-model" value must be a Date object'); } this.refreshView(); }, this.refreshView = function () { if (this.element) { a.selectedDt = null, this._refreshView(), a.activeDt && (a.activeDateId = a.activeDt.uid); let b = l.$viewValue ? new Date(l.$viewValue) : null; b = j.fromTimezone(b, m.timezone), l.$setValidity('dateDisabled', !b || this.element && !this.isDisabled(b)); } }, this.createDateObject = function (b, c) {
    let d = l.$viewValue ? new Date(l.$viewValue) : null; d = j.fromTimezone(d, m.timezone); const e = {
      date: b, label: g(b, c.replace(/d!/, 'dd')).replace(/M!/, 'MM'), selected: d && this.compare(b, d) === 0, disabled: this.isDisabled(b), current: this.compare(b, new Date()) === 0, customClass: this.customClass(b) || null,
    }; return d && this.compare(b, d) === 0 && (a.selectedDt = e), k.activeDate && this.compare(e.date, k.activeDate) === 0 && (a.activeDt = e), e;
  }, this.isDisabled = function (c) { return a.disabled || this.minDate && this.compare(c, this.minDate) < 0 || this.maxDate && this.compare(c, this.maxDate) > 0 || b.dateDisabled && a.dateDisabled({ date: c, mode: a.datepickerMode }); }, this.customClass = function (b) { return a.customClass({ date: b, mode: a.datepickerMode }); }, this.split = function (a, b) { for (var c = []; a.length > 0;)c.push(a.splice(0, b)); return c; }, a.select = function (b) { if (a.datepickerMode === k.minMode) { let c = l.$viewValue ? j.fromTimezone(new Date(l.$viewValue), m.timezone) : new Date(0, 0, 0, 0, 0, 0, 0); c.setFullYear(b.getFullYear(), b.getMonth(), b.getDate()), c = j.toTimezone(c, m.timezone), l.$setViewValue(c), l.$render(); } else k.activeDate = b, a.datepickerMode = k.modes[k.modes.indexOf(a.datepickerMode) - 1]; }, a.move = function (a) { const b = k.activeDate.getFullYear() + a * (k.step.years || 0); const c = k.activeDate.getMonth() + a * (k.step.months || 0); k.activeDate.setFullYear(b, c, 1), k.refreshView(); }, a.toggleMode = function (b) { b = b || 1, a.datepickerMode === k.maxMode && b === 1 || a.datepickerMode === k.minMode && b === -1 || (a.datepickerMode = k.modes[k.modes.indexOf(a.datepickerMode) + b]); }, a.keys = {
    13: 'enter', 32: 'space', 33: 'pageup', 34: 'pagedown', 35: 'end', 36: 'home', 37: 'left', 38: 'up', 39: 'right', 40: 'down',
  }; const o = function () { k.element[0].focus(); }; a.$on('uib:datepicker.focus', o), a.keydown = function (b) { const c = a.keys[b.which]; if (c && !b.shiftKey && !b.altKey && !a.disabled) if (b.preventDefault(), k.shortcutPropagation || b.stopPropagation(), c === 'enter' || c === 'space') { if (k.isDisabled(k.activeDate)) return; a.select(k.activeDate); } else !b.ctrlKey || c !== 'up' && c !== 'down' ? (k.handleKeyDown(c, b), k.refreshView()) : a.toggleMode(c === 'up' ? 1 : -1); }, a.$on('$destroy', () => { for (;n.length;)n.shift()(); });
}])
  .controller('UibDaypickerController', ['$scope', '$element', 'dateFilter', function (a, b, c) { function d(a, b) { return b !== 1 || a % 4 !== 0 || a % 100 === 0 && a % 400 !== 0 ? f[b] : 29; } function e(a) { const b = new Date(a); b.setDate(b.getDate() + 4 - (b.getDay() || 7)); const c = b.getTime(); return b.setMonth(0), b.setDate(1), Math.floor(Math.round((c - b) / 864e5) / 7) + 1; } var f = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; this.step = { months: 1 }, this.element = b, this.init = function (b) { angular.extend(b, this), a.showWeeks = b.showWeeks, b.refreshView(); }, this.getDates = function (a, b) { for (var c, d = new Array(b), e = new Date(a), f = 0; b > f;)c = new Date(e), d[f++] = c, e.setDate(e.getDate() + 1); return d; }, this._refreshView = function () { const b = this.activeDate.getFullYear(); const d = this.activeDate.getMonth(); const f = new Date(this.activeDate); f.setFullYear(b, d, 1); const g = this.startingDay - f.getDay(); const h = g > 0 ? 7 - g : -g; const i = new Date(f); h > 0 && i.setDate(-h + 1); for (var j = this.getDates(i, 42), k = 0; k < 42; k++)j[k] = angular.extend(this.createDateObject(j[k], this.formatDay), { secondary: j[k].getMonth() !== d, uid: `${a.uniqueId}-${k}` }); a.labels = new Array(7); for (let l = 0; l < 7; l++)a.labels[l] = { abbr: c(j[l].date, this.formatDayHeader), full: c(j[l].date, 'EEEE') }; if (a.title = c(this.activeDate, this.formatDayTitle), a.rows = this.split(j, 7), a.showWeeks) { a.weekNumbers = []; for (let m = (11 - this.startingDay) % 7, n = a.rows.length, o = 0; n > o; o++)a.weekNumbers.push(e(a.rows[o][m].date)); } }, this.compare = function (a, b) { const c = new Date(a.getFullYear(), a.getMonth(), a.getDate()); const d = new Date(b.getFullYear(), b.getMonth(), b.getDate()); return c.setFullYear(a.getFullYear()), d.setFullYear(b.getFullYear()), c - d; }, this.handleKeyDown = function (a, b) { let c = this.activeDate.getDate(); if (a === 'left')c -= 1; else if (a === 'up')c -= 7; else if (a === 'right')c += 1; else if (a === 'down')c += 7; else if (a === 'pageup' || a === 'pagedown') { const e = this.activeDate.getMonth() + (a === 'pageup' ? -1 : 1); this.activeDate.setMonth(e, 1), c = Math.min(d(this.activeDate.getFullYear(), this.activeDate.getMonth()), c); } else a === 'home' ? c = 1 : a === 'end' && (c = d(this.activeDate.getFullYear(), this.activeDate.getMonth())); this.activeDate.setDate(c); }; }])
  .controller('UibMonthpickerController', ['$scope', '$element', 'dateFilter', function (a, b, c) { this.step = { years: 1 }, this.element = b, this.init = function (a) { angular.extend(a, this), a.refreshView(); }, this._refreshView = function () { for (var b, d = new Array(12), e = this.activeDate.getFullYear(), f = 0; f < 12; f++)b = new Date(this.activeDate), b.setFullYear(e, f, 1), d[f] = angular.extend(this.createDateObject(b, this.formatMonth), { uid: `${a.uniqueId}-${f}` }); a.title = c(this.activeDate, this.formatMonthTitle), a.rows = this.split(d, 3); }, this.compare = function (a, b) { const c = new Date(a.getFullYear(), a.getMonth()); const d = new Date(b.getFullYear(), b.getMonth()); return c.setFullYear(a.getFullYear()), d.setFullYear(b.getFullYear()), c - d; }, this.handleKeyDown = function (a, b) { let c = this.activeDate.getMonth(); if (a === 'left')c -= 1; else if (a === 'up')c -= 3; else if (a === 'right')c += 1; else if (a === 'down')c += 3; else if (a === 'pageup' || a === 'pagedown') { const d = this.activeDate.getFullYear() + (a === 'pageup' ? -1 : 1); this.activeDate.setFullYear(d); } else a === 'home' ? c = 0 : a === 'end' && (c = 11); this.activeDate.setMonth(c); }; }])
  .controller('UibYearpickerController', ['$scope', '$element', 'dateFilter', function (a, b, c) { function d(a) { return parseInt((a - 1) / f, 10) * f + 1; } let e; let f; this.element = b, this.yearpickerInit = function () { e = this.yearColumns, f = this.yearRows * e, this.step = { years: f }; }, this._refreshView = function () { for (var b, c = new Array(f), g = 0, h = d(this.activeDate.getFullYear()); f > g; g++)b = new Date(this.activeDate), b.setFullYear(h + g, 0, 1), c[g] = angular.extend(this.createDateObject(b, this.formatYear), { uid: `${a.uniqueId}-${g}` }); a.title = [c[0].label, c[f - 1].label].join(' - '), a.rows = this.split(c, e), a.columns = e; }, this.compare = function (a, b) { return a.getFullYear() - b.getFullYear(); }, this.handleKeyDown = function (a, b) { let c = this.activeDate.getFullYear(); a === 'left' ? c -= 1 : a === 'up' ? c -= e : a === 'right' ? c += 1 : a === 'down' ? c += e : a === 'pageup' || a === 'pagedown' ? c += (a === 'pageup' ? -1 : 1) * f : a === 'home' ? c = d(this.activeDate.getFullYear()) : a === 'end' && (c = d(this.activeDate.getFullYear()) + f - 1), this.activeDate.setFullYear(c); }; }])
  .directive('uibDatepicker', () => ({
    replace: !0,
    templateUrl(a, b) { return b.templateUrl || 'uib/template/datepicker/datepicker.html'; },
    scope: {
      datepickerMode: '=?', dateDisabled: '&', customClass: '&', shortcutPropagation: '&?',
    },
    require: ['uibDatepicker', '^ngModel'],
    controller: 'UibDatepickerController',
    controllerAs: 'datepicker',
    link(a, b, c, d) { const e = d[0]; const f = d[1]; e.init(f); },
  }))
  .directive('uibDaypicker', () => ({
    replace: !0, templateUrl(a, b) { return b.templateUrl || 'uib/template/datepicker/day.html'; }, require: ['^uibDatepicker', 'uibDaypicker'], controller: 'UibDaypickerController', link(a, b, c, d) { const e = d[0]; const f = d[1]; f.init(e); },
  }))
  .directive('uibMonthpicker', () => ({
    replace: !0, templateUrl(a, b) { return b.templateUrl || 'uib/template/datepicker/month.html'; }, require: ['^uibDatepicker', 'uibMonthpicker'], controller: 'UibMonthpickerController', link(a, b, c, d) { const e = d[0]; const f = d[1]; f.init(e); },
  }))
  .directive('uibYearpicker', () => ({
    replace: !0, templateUrl(a, b) { return b.templateUrl || 'uib/template/datepicker/year.html'; }, require: ['^uibDatepicker', 'uibYearpicker'], controller: 'UibYearpickerController', link(a, b, c, d) { const e = d[0]; angular.extend(e, d[1]), e.yearpickerInit(), e.refreshView(); },
  }))
  .constant('uibDatepickerPopupConfig', {
    altInputFormats: [], appendToBody: !1, clearText: 'Clear', closeOnDateSelection: !0, closeText: 'Done', currentText: 'Today', datepickerPopup: 'yyyy-MM-dd', datepickerPopupTemplateUrl: 'uib/template/datepicker/popup.html', datepickerTemplateUrl: 'uib/template/datepicker/datepicker.html', html5Types: { date: 'yyyy-MM-dd', 'datetime-local': 'yyyy-MM-ddTHH:mm:ss.sss', month: 'yyyy-MM' }, onOpenFocus: !0, showButtonBar: !0,
  })
  .controller('UibDatepickerPopupController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$document', '$rootScope', '$uibPosition', 'dateFilter', 'uibDateParser', 'uibDatepickerPopupConfig', '$timeout', 'uibDatepickerConfig', function (a, b, c, d, e, f, g, h, i, j, k, l, m) {
    function n(a) { return a.replace(/([A-Z])/g, a => `-${a.toLowerCase()}`); } function o(b) { let c = j.parse(b, t, a.date); if (isNaN(c)) for (let d = 0; d < E.length; d++) if (c = j.parse(b, E[d], a.date), !isNaN(c)) return c; return c; } function p(a) { if (angular.isNumber(a) && (a = new Date(a)), !a) return null; if (angular.isDate(a) && !isNaN(a)) return a; if (angular.isString(a)) { const b = o(a); if (!isNaN(b)) return j.toTimezone(b, C.timezone); } return B.$options && B.$options.allowInvalid ? a : void 0; } function q(a, b) { let d = a || b; return c.ngRequired || d ? (angular.isNumber(d) && (d = new Date(d)), d ? angular.isDate(d) && !isNaN(d) ? !0 : angular.isString(d) ? !isNaN(o(b)) : !1 : !0) : !0; } function r(c) { if (a.isOpen || !a.disabled) { const d = D[0]; const e = b[0].contains(c.target); const f = void 0 !== d.contains && d.contains(c.target); !a.isOpen || e || f || a.$apply(() => { a.isOpen = !1; }); } } function s(c) { c.which === 27 && a.isOpen ? (c.preventDefault(), c.stopPropagation(), a.$apply(() => { a.isOpen = !1; }), b[0].focus()) : c.which !== 40 || a.isOpen || (c.preventDefault(), c.stopPropagation(), a.$apply(() => { a.isOpen = !0; })); } let t; let u; let v; let w; let x; let y; let z; let A; let B; let C; let D; let E; const F = {}; let G = !1; const H = []; a.watchData = {}, this.init = function (h) {
      if (B = h, C = h.$options || m.ngModelOptions, u = angular.isDefined(c.closeOnDateSelection) ? a.$parent.$eval(c.closeOnDateSelection) : k.closeOnDateSelection, v = angular.isDefined(c.datepickerAppendToBody) ? a.$parent.$eval(c.datepickerAppendToBody) : k.appendToBody, w = angular.isDefined(c.onOpenFocus) ? a.$parent.$eval(c.onOpenFocus) : k.onOpenFocus, x = angular.isDefined(c.datepickerPopupTemplateUrl) ? c.datepickerPopupTemplateUrl : k.datepickerPopupTemplateUrl, y = angular.isDefined(c.datepickerTemplateUrl) ? c.datepickerTemplateUrl : k.datepickerTemplateUrl, E = angular.isDefined(c.altInputFormats) ? a.$parent.$eval(c.altInputFormats) : k.altInputFormats, a.showButtonBar = angular.isDefined(c.showButtonBar) ? a.$parent.$eval(c.showButtonBar) : k.showButtonBar, k.html5Types[c.type] ? (t = k.html5Types[c.type], G = !0) : (t = c.uibDatepickerPopup || k.datepickerPopup, c.$observe('uibDatepickerPopup', (a, b) => { const c = a || k.datepickerPopup; if (c !== t && (t = c, B.$modelValue = null, !t)) throw new Error('uibDatepickerPopup must have a date format specified.'); })), !t) throw new Error('uibDatepickerPopup must have a date format specified.'); if (G && c.uibDatepickerPopup) throw new Error('HTML5 date input types do not support custom formats.'); z = angular.element('<div uib-datepicker-popup-wrap><div uib-datepicker></div></div>'), a.ngModelOptions = angular.copy(C), a.ngModelOptions.timezone = null, z.attr({
        'ng-model': 'date', 'ng-model-options': 'ngModelOptions', 'ng-change': 'dateSelection(date)', 'template-url': x,
      }), A = angular.element(z.children()[0]), A.attr('template-url', y), G && c.type === 'month' && (A.attr('datepicker-mode', '"month"'), A.attr('min-mode', 'month')), a.datepickerOptions && angular.forEach(a.datepickerOptions, (a, b) => { ['minDate', 'maxDate', 'minMode', 'maxMode', 'initDate', 'datepickerMode'].indexOf(b) === -1 ? A.attr(n(b), a) : A.attr(n(b), `datepickerOptions.${b}`); }), angular.forEach(['minMode', 'maxMode', 'datepickerMode', 'shortcutPropagation'], (b) => { if (c[b]) { const d = e(c[b]); const f = { get() { return d(a.$parent); } }; if (A.attr(n(b), `watchData.${b}`), b === 'datepickerMode') { const g = d.assign; f.set = function (b) { g(a.$parent, b); }; }Object.defineProperty(a.watchData, b, f); } }), angular.forEach(['minDate', 'maxDate', 'initDate'], (b) => { if (c[b]) { const d = e(c[b]); H.push(a.$parent.$watch(d, (c) => { b === 'minDate' || b === 'maxDate' ? (c === null ? F[b] = null : angular.isDate(c) ? F[b] = j.fromTimezone(new Date(c), C.timezone) : F[b] = new Date(i(c, 'medium')), a.watchData[b] = c === null ? null : F[b]) : a.watchData[b] = j.fromTimezone(new Date(c), C.timezone); })), A.attr(n(b), `watchData.${b}`); } }), c.dateDisabled && A.attr('date-disabled', 'dateDisabled({ date: date, mode: mode })'), angular.forEach(['formatDay', 'formatMonth', 'formatYear', 'formatDayHeader', 'formatDayTitle', 'formatMonthTitle', 'showWeeks', 'startingDay', 'yearRows', 'yearColumns'], (a) => { angular.isDefined(c[a]) && A.attr(n(a), c[a]); }), c.customClass && A.attr('custom-class', 'customClass({ date: date, mode: mode })'), G ? B.$formatters.push(b => a.date = j.fromTimezone(b, C.timezone), b) : (B.$$parserName = 'date', B.$validators.date = q, B.$parsers.unshift(p), B.$formatters.push(b => (B.$isEmpty(b) ? (a.date = b, b) : (a.date = j.fromTimezone(b, C.timezone), t = t.replace(/M!/, 'MM').replace(/d!/, 'dd'), i(a.date, t))))), B.$viewChangeListeners.push(() => { a.date = o(B.$viewValue); }), b.on('keydown', s), D = d(z)(a), z.remove(), v ? f.find('body').append(D) : b.after(D), a.$on('$destroy', () => { for (a.isOpen === !0 && (g.$$phase || a.$apply(() => { a.isOpen = !1; })), D.remove(), b.off('keydown', s), f.off('click', r); H.length;)H.shift()(); });
    }, a.getText = function (b) { return a[`${b}Text`] || k[`${b}Text`]; }, a.isDisabled = function (b) { return b === 'today' && (b = new Date()), a.watchData.minDate && a.compare(b, F.minDate) < 0 || a.watchData.maxDate && a.compare(b, F.maxDate) > 0; }, a.compare = function (a, b) { return new Date(a.getFullYear(), a.getMonth(), a.getDate()) - new Date(b.getFullYear(), b.getMonth(), b.getDate()); }, a.dateSelection = function (c) { angular.isDefined(c) && (a.date = c); const d = a.date ? i(a.date, t) : null; b.val(d), B.$setViewValue(d), u && (a.isOpen = !1, b[0].focus()); }, a.keydown = function (c) { c.which === 27 && (c.stopPropagation(), a.isOpen = !1, b[0].focus()); }, a.select = function (b) { if (b === 'today') { const c = new Date(); angular.isDate(a.date) ? (b = new Date(a.date), b.setFullYear(c.getFullYear(), c.getMonth(), c.getDate())) : b = new Date(c.setHours(0, 0, 0, 0)); }a.dateSelection(b); }, a.close = function () { a.isOpen = !1, b[0].focus(); }, a.disabled = angular.isDefined(c.disabled) || !1, c.ngDisabled && H.push(a.$parent.$watch(e(c.ngDisabled), (b) => { a.disabled = b; })), a.$watch('isOpen', (c) => { c ? a.disabled ? a.isOpen = !1 : (a.position = v ? h.offset(b) : h.position(b), a.position.top = a.position.top + b.prop('offsetHeight'), l(() => { w && a.$broadcast('uib:datepicker.focus'), f.on('click', r); }, 0, !1)) : f.off('click', r); });
  }])
  .directive('uibDatepickerPopup', () => ({
    require: ['ngModel', 'uibDatepickerPopup'],
    controller: 'UibDatepickerPopupController',
    scope: {
      datepickerOptions: '=?', isOpen: '=?', currentText: '@', clearText: '@', closeText: '@', dateDisabled: '&', customClass: '&',
    },
    link(a, b, c, d) { const e = d[0]; const f = d[1]; f.init(e); },
  }))
  .directive('uibDatepickerPopupWrap', () => ({ replace: !0, transclude: !0, templateUrl(a, b) { return b.templateUrl || 'uib/template/datepicker/popup.html'; } })), angular.module('ui.bootstrap.debounce', []).factory('$$debounce', ['$timeout', function (a) { return function (b, c) { let d; return function () { const e = this; const f = Array.prototype.slice.call(arguments); d && a.cancel(d), d = a(() => { b.apply(e, f); }, c); }; }; }]), angular.module('ui.bootstrap.dropdown', ['ui.bootstrap.position']).constant('uibDropdownConfig', { appendToOpenClass: 'uib-dropdown-open', openClass: 'open' }).service('uibDropdownService', ['$document', '$rootScope', function (a, b) { let c = null; this.open = function (b) { c || (a.on('click', d), a.on('keydown', e)), c && c !== b && (c.isOpen = !1), c = b; }, this.close = function (b) { c === b && (c = null, a.off('click', d), a.off('keydown', e)); }; var d = function (a) { if (c && !(a && c.getAutoClose() === 'disabled' || a && a.which === 3)) { const d = c.getToggleElement(); if (!(a && d && d[0].contains(a.target))) { const e = c.getDropdownElement(); a && c.getAutoClose() === 'outsideClick' && e && e[0].contains(a.target) || (c.isOpen = !1, b.$$phase || c.$apply()); } } }; var e = function (a) { a.which === 27 ? (c.focusToggleElement(), d()) : c.isKeynavEnabled() && [38, 40].indexOf(a.which) !== -1 && c.isOpen && (a.preventDefault(), a.stopPropagation(), c.focusDropdownEntry(a.which)); }; }]).controller('UibDropdownController', ['$scope', '$element', '$attrs', '$parse', 'uibDropdownConfig', 'uibDropdownService', '$animate', '$uibPosition', '$document', '$compile', '$templateRequest', function (a, b, c, d, e, f, g, h, i, j, k) { let l; let m; const n = this; const o = a.$new(); const p = e.appendToOpenClass; const q = e.openClass; let r = angular.noop; const s = c.onToggle ? d(c.onToggle) : angular.noop; let t = !1; let u = null; let v = !1; const w = i.find('body'); b.addClass('dropdown'), this.init = function () { if (c.isOpen && (m = d(c.isOpen), r = m.assign, a.$watch(m, (a) => { o.isOpen = !!a; })), angular.isDefined(c.dropdownAppendTo)) { const e = d(c.dropdownAppendTo)(o); e && (u = angular.element(e)); }t = angular.isDefined(c.dropdownAppendToBody), v = angular.isDefined(c.keyboardNav), t && !u && (u = w), u && n.dropdownMenu && (u.append(n.dropdownMenu), b.on('$destroy', () => { n.dropdownMenu.remove(); })); }, this.toggle = function (a) { return o.isOpen = arguments.length ? !!a : !o.isOpen; }, this.isOpen = function () { return o.isOpen; }, o.getToggleElement = function () { return n.toggleElement; }, o.getAutoClose = function () { return c.autoClose || 'always'; }, o.getElement = function () { return b; }, o.isKeynavEnabled = function () { return v; }, o.focusDropdownEntry = function (a) { const c = n.dropdownMenu ? angular.element(n.dropdownMenu).find('a') : b.find('ul').eq(0).find('a'); switch (a) { case 40: angular.isNumber(n.selectedOption) ? n.selectedOption = n.selectedOption === c.length - 1 ? n.selectedOption : n.selectedOption + 1 : n.selectedOption = 0; break; case 38: angular.isNumber(n.selectedOption) ? n.selectedOption = n.selectedOption === 0 ? 0 : n.selectedOption - 1 : n.selectedOption = c.length - 1; }c[n.selectedOption].focus(); }, o.getDropdownElement = function () { return n.dropdownMenu; }, o.focusToggleElement = function () { n.toggleElement && n.toggleElement[0].focus(); }, o.$watch('isOpen', (c, d) => { if (u && n.dropdownMenu) { let e; let i; const m = h.positionElements(b, n.dropdownMenu, 'bottom-left', !0); if (e = { top: `${m.top}px`, display: c ? 'block' : 'none' }, i = n.dropdownMenu.hasClass('dropdown-menu-right'), i ? (e.left = 'auto', e.right = `${window.innerWidth - (m.left + b.prop('offsetWidth'))}px`) : (e.left = `${m.left}px`, e.right = 'auto'), !t) { const v = h.offset(u); e.top = `${m.top - v.top}px`, i ? e.right = `${window.innerWidth - (m.left - v.left + b.prop('offsetWidth'))}px` : e.left = `${m.left - v.left}px`; }n.dropdownMenu.css(e); } const w = u || b; if (g[c ? 'addClass' : 'removeClass'](w, u ? p : q).then(() => { angular.isDefined(c) && c !== d && s(a, { open: !!c }); }), c)n.dropdownMenuTemplateUrl && k(n.dropdownMenuTemplateUrl).then((a) => { l = o.$new(), j(a.trim())(l, (a) => { const b = a; n.dropdownMenu.replaceWith(b), n.dropdownMenu = b; }); }), o.focusToggleElement(), f.open(o); else { if (n.dropdownMenuTemplateUrl) { l && l.$destroy(); const x = angular.element('<ul class="dropdown-menu"></ul>'); n.dropdownMenu.replaceWith(x), n.dropdownMenu = x; }f.close(o), n.selectedOption = null; }angular.isFunction(r) && r(a, c); }), a.$on('$locationChangeSuccess', () => { o.getAutoClose() !== 'disabled' && (o.isOpen = !1); }); }])
  .directive('uibDropdown', () => ({ controller: 'UibDropdownController', link(a, b, c, d) { d.init(); } }))
  .directive('uibDropdownMenu', () => ({ restrict: 'A', require: '?^uibDropdown', link(a, b, c, d) { if (d && !angular.isDefined(c.dropdownNested)) { b.addClass('dropdown-menu'); const e = c.templateUrl; e && (d.dropdownMenuTemplateUrl = e), d.dropdownMenu || (d.dropdownMenu = b); } } }))
  .directive('uibDropdownToggle', () => ({ require: '?^uibDropdown', link(a, b, c, d) { if (d) { b.addClass('dropdown-toggle'), d.toggleElement = b; const e = function (e) { e.preventDefault(), b.hasClass('disabled') || c.disabled || a.$apply(() => { d.toggle(); }); }; b.bind('click', e), b.attr({ 'aria-haspopup': !0, 'aria-expanded': !1 }), a.$watch(d.isOpen, (a) => { b.attr('aria-expanded', !!a); }), a.$on('$destroy', () => { b.unbind('click', e); }); } } })), angular.module('ui.bootstrap.stackedMap', []).factory('$$stackedMap', () => ({
  createNew() {
    const a = []; return {
      add(b, c) { a.push({ key: b, value: c }); }, get(b) { for (let c = 0; c < a.length; c++) if (b === a[c].key) return a[c]; }, keys() { for (var b = [], c = 0; c < a.length; c++)b.push(a[c].key); return b; }, top() { return a[a.length - 1]; }, remove(b) { for (var c = -1, d = 0; d < a.length; d++) if (b === a[d].key) { c = d; break; } return a.splice(c, 1)[0]; }, removeTop() { return a.splice(a.length - 1, 1)[0]; }, length() { return a.length; },
    };
  },
})), angular.module('ui.bootstrap.modal', ['ui.bootstrap.stackedMap']).factory('$$multiMap', () => ({
  createNew() {
    const a = {}; return {
      entries() { return Object.keys(a).map(b => ({ key: b, value: a[b] })); }, get(b) { return a[b]; }, hasKey(b) { return !!a[b]; }, keys() { return Object.keys(a); }, put(b, c) { a[b] || (a[b] = []), a[b].push(c); }, remove(b, c) { const d = a[b]; if (d) { const e = d.indexOf(c); e !== -1 && d.splice(e, 1), d.length || delete a[b]; } },
    };
  },
})).provider('$uibResolve', function () { const a = this; this.resolver = null, this.setResolver = function (a) { this.resolver = a; }, this.$get = ['$injector', '$q', function (b, c) { const d = a.resolver ? b.get(a.resolver) : null; return { resolve(a, e, f, g) { if (d) return d.resolve(a, e, f, g); const h = []; return angular.forEach(a, (a) => { angular.isFunction(a) || angular.isArray(a) ? h.push(c.resolve(b.invoke(a))) : angular.isString(a) ? h.push(c.resolve(b.get(a))) : h.push(c.resolve(a)); }), c.all(h).then((b) => { const c = {}; let d = 0; return angular.forEach(a, (a, e) => { c[e] = b[d++]; }), c; }); } }; }]; }).directive('uibModalBackdrop', ['$animateCss', '$injector', '$uibModalStack', function (a, b, c) { function d(b, d, e) { e.modalInClass && (a(d, { addClass: e.modalInClass }).start(), b.$on(c.NOW_CLOSING_EVENT, (c, f) => { const g = f(); b.modalOptions.animation ? a(d, { removeClass: e.modalInClass }).start().then(g) : g(); })); } return { replace: !0, templateUrl: 'uib/template/modal/backdrop.html', compile(a, b) { return a.addClass(b.backdropClass), d; } }; }])
  .directive('uibModalWindow', ['$uibModalStack', '$q', '$animate', '$animateCss', '$document', function (a, b, c, d, e) {
    return {
      scope: { index: '@' }, replace: !0, transclude: !0, templateUrl(a, b) { return b.templateUrl || 'uib/template/modal/window.html'; }, link(f, g, h) { g.addClass(h.windowClass || ''), g.addClass(h.windowTopClass || ''), f.size = h.size, f.close = function (b) { const c = a.getTop(); c && c.value.backdrop && c.value.backdrop !== 'static' && b.target === b.currentTarget && (b.preventDefault(), b.stopPropagation(), a.dismiss(c.key, 'backdrop click')); }, g.on('click', f.close), f.$isRendered = !0; const i = b.defer(); h.$observe('modalRender', (a) => { a === 'true' && i.resolve(); }), i.promise.then(() => { let i = null; h.modalInClass && (i = d(g, { addClass: h.modalInClass }).start(), f.$on(a.NOW_CLOSING_EVENT, (a, b) => { const e = b(); d ? d(g, { removeClass: h.modalInClass }).start().then(e) : c.removeClass(g, h.modalInClass).then(e); })), b.when(i).then(() => { if (!e[0].activeElement || !g[0].contains(e[0].activeElement)) { const a = g[0].querySelector('[autofocus]'); a ? a.focus() : g[0].focus(); } }); const j = a.getTop(); j && a.modalRendered(j.key); }); },
    };
  }])
  .directive('uibModalAnimationClass', () => ({ compile(a, b) { b.modalAnimation && a.addClass(b.uibModalAnimationClass); } }))
  .directive('uibModalTransclude', () => ({ link(a, b, c, d, e) { e(a.$parent, (a) => { b.empty(), b.append(a); }); } }))
  .factory('$uibModalStack', ['$animate', '$animateCss', '$document', '$compile', '$rootScope', '$q', '$$multiMap', '$$stackedMap', function (a, b, c, d, e, f, g, h) {
    function i() { for (var a = -1, b = t.keys(), c = 0; c < b.length; c++)t.get(b[c]).value.backdrop && (a = c); return a; } function j(a, b) { const c = t.get(a).value; const d = c.appendTo; t.remove(a), m(c.modalDomEl, c.modalScope, () => { const b = c.openedClass || s; u.remove(b, a), d.toggleClass(b, u.hasKey(b)), k(!0); }, c.closedDeferred), l(), b && b.focus ? b.focus() : d.focus && d.focus(); } function k(a) { let b; t.length() > 0 && (b = t.top().value, b.modalDomEl.toggleClass(b.windowTopClass || '', a)); } function l() { if (p && i() === -1) { let a = q; m(p, q, () => { a = null; }), p = void 0, q = void 0; } } function m(a, c, d, e) { function g() { g.done || (g.done = !0, b(a, { event: 'leave' }).start().then(() => { a.remove(), e && e.resolve(); }), c.$destroy(), d && d()); } let h; let i = null; const j = function () { return h || (h = f.defer(), i = h.promise), function () { h.resolve(); }; }; return c.$broadcast(v.NOW_CLOSING_EVENT, j), f.when(i).then(g); } function n(a) { if (a.isDefaultPrevented()) return a; const b = t.top(); if (b) switch (a.which) { case 27: b.value.keyboard && (a.preventDefault(), e.$apply(() => { v.dismiss(b.key, 'escape key press'); })); break; case 9: v.loadFocusElementList(b); var c = !1; a.shiftKey ? v.isFocusInFirstItem(a) && (c = v.focusLastFocusableElement()) : v.isFocusInLastItem(a) && (c = v.focusFirstFocusableElement()), c && (a.preventDefault(), a.stopPropagation()); } } function o(a, b, c) { return !a.value.modalScope.$broadcast('modal.closing', b, c).defaultPrevented; } let p; let q; let r; var s = 'modal-open'; var t = h.createNew(); var u = g.createNew(); var v = { NOW_CLOSING_EVENT: 'modal.stack.now-closing' }; let w = 0; const x = 'a[href], area[href], input:not([disabled]), button:not([disabled]),select:not([disabled]), textarea:not([disabled]), iframe, object, embed, *[tabindex], *[contenteditable=true]'; return e.$watch(i, (a) => { q && (q.index = a); }), c.on('keydown', n), e.$on('$destroy', () => { c.off('keydown', n); }), v.open = function (b, f) {
      const g = c[0].activeElement; const h = f.openedClass || s; k(!1), t.add(b, {
        deferred: f.deferred, renderDeferred: f.renderDeferred, closedDeferred: f.closedDeferred, modalScope: f.scope, backdrop: f.backdrop, keyboard: f.keyboard, openedClass: f.openedClass, windowTopClass: f.windowTopClass, animation: f.animation, appendTo: f.appendTo,
      }), u.put(h, b); const j = f.appendTo; const l = i(); if (!j.length) throw new Error('appendTo element not found. Make sure that the element passed is in DOM.'); l >= 0 && !p && (q = e.$new(!0), q.modalOptions = f, q.index = l, p = angular.element('<div uib-modal-backdrop="modal-backdrop"></div>'), p.attr('backdrop-class', f.backdropClass), f.animation && p.attr('modal-animation', 'true'), d(p)(q), a.enter(p, j)); const m = angular.element('<div uib-modal-window="modal-window"></div>'); m.attr({
        'template-url': f.windowTemplateUrl, 'window-class': f.windowClass, 'window-top-class': f.windowTopClass, size: f.size, index: t.length() - 1, animate: 'animate',
      }).html(f.content), f.animation && m.attr('modal-animation', 'true'), a.enter(d(m)(f.scope), j).then(() => { a.addClass(j, h); }), t.top().value.modalDomEl = m, t.top().value.modalOpener = g, v.clearFocusListCache();
    }, v.close = function (a, b) { const c = t.get(a); return c && o(c, b, !0) ? (c.value.modalScope.$$uibDestructionScheduled = !0, c.value.deferred.resolve(b), j(a, c.value.modalOpener), !0) : !c; }, v.dismiss = function (a, b) { const c = t.get(a); return c && o(c, b, !1) ? (c.value.modalScope.$$uibDestructionScheduled = !0, c.value.deferred.reject(b), j(a, c.value.modalOpener), !0) : !c; }, v.dismissAll = function (a) { for (let b = this.getTop(); b && this.dismiss(b.key, a);)b = this.getTop(); }, v.getTop = function () { return t.top(); }, v.modalRendered = function (a) { const b = t.get(a); b && b.value.renderDeferred.resolve(); }, v.focusFirstFocusableElement = function () { return r.length > 0 ? (r[0].focus(), !0) : !1; }, v.focusLastFocusableElement = function () { return r.length > 0 ? (r[r.length - 1].focus(), !0) : !1; }, v.isFocusInFirstItem = function (a) { return r.length > 0 ? (a.target || a.srcElement) === r[0] : !1; }, v.isFocusInLastItem = function (a) { return r.length > 0 ? (a.target || a.srcElement) === r[r.length - 1] : !1; }, v.clearFocusListCache = function () { r = [], w = 0; }, v.loadFocusElementList = function (a) { if ((void 0 === r || !r.length) && a) { const b = a.value.modalDomEl; b && b.length && (r = b[0].querySelectorAll(x)); } }, v;
  }])
  .provider('$uibModal', () => {
    var a = {
      options: { animation: !0, backdrop: !0, keyboard: !0 },
      $get: ['$rootScope', '$q', '$document', '$templateRequest', '$controller', '$uibResolve', '$uibModalStack', function (b, c, d, e, f, g, h) {
        function i(a) { return a.template ? c.when(a.template) : e(angular.isFunction(a.templateUrl) ? a.templateUrl() : a.templateUrl); } const j = {}; let k = null; return j.getPromiseChain = function () { return k; }, j.open = function (e) {
          function j() { return r; } const l = c.defer(); const m = c.defer(); const n = c.defer(); const o = c.defer(); var p = {
            result: l.promise, opened: m.promise, closed: n.promise, rendered: o.promise, close(a) { return h.close(p, a); }, dismiss(a) { return h.dismiss(p, a); },
          }; if (e = angular.extend({}, a.options, e), e.resolve = e.resolve || {}, e.appendTo = e.appendTo || d.find('body').eq(0), !e.template && !e.templateUrl) throw new Error('One of template or templateUrl options is required.'); let q; var r = c.all([i(e), g.resolve(e.resolve, {}, null, null)]); return q = k = c.all([k]).then(j, j).then((a) => {
            const c = e.scope || b; const d = c.$new(); d.$close = p.close, d.$dismiss = p.dismiss, d.$on('$destroy', () => { d.$$uibDestructionScheduled || d.$dismiss('$uibUnscheduledDestruction'); }); let g; const i = {}; e.controller && (i.$scope = d, i.$uibModalInstance = p, angular.forEach(a[1], (a, b) => { i[b] = a; }), g = f(e.controller, i), e.controllerAs && (e.bindToController && (g.$close = d.$close, g.$dismiss = d.$dismiss, angular.extend(g, c)), d[e.controllerAs] = g)), h.open(p, {
              scope: d, deferred: l, renderDeferred: o, closedDeferred: n, content: a[0], animation: e.animation, backdrop: e.backdrop, keyboard: e.keyboard, backdropClass: e.backdropClass, windowTopClass: e.windowTopClass, windowClass: e.windowClass, windowTemplateUrl: e.windowTemplateUrl, size: e.size, openedClass: e.openedClass, appendTo: e.appendTo,
            }), m.resolve(!0);
          }, (a) => { m.reject(a), l.reject(a); }).finally(() => { k === q && (k = null); }), p;
        }, j;
      }],
    }; return a;
  }), angular.module('ui.bootstrap.paging', []).factory('uibPaging', ['$parse', function (a) { return { create(b, c, d) { b.setNumPages = d.numPages ? a(d.numPages).assign : angular.noop, b.ngModelCtrl = { $setViewValue: angular.noop }, b._watchers = [], b.init = function (e, f) { b.ngModelCtrl = e, b.config = f, e.$render = function () { b.render(); }, d.itemsPerPage ? b._watchers.push(c.$parent.$watch(a(d.itemsPerPage), (a) => { b.itemsPerPage = parseInt(a, 10), c.totalPages = b.calculateTotalPages(), b.updatePage(); })) : b.itemsPerPage = f.itemsPerPage, c.$watch('totalItems', (a, d) => { (angular.isDefined(a) || a !== d) && (c.totalPages = b.calculateTotalPages(), b.updatePage()); }); }, b.calculateTotalPages = function () { const a = b.itemsPerPage < 1 ? 1 : Math.ceil(c.totalItems / b.itemsPerPage); return Math.max(a || 0, 1); }, b.render = function () { c.page = parseInt(b.ngModelCtrl.$viewValue, 10) || 1; }, c.selectPage = function (a, d) { d && d.preventDefault(); const e = !c.ngDisabled || !d; e && c.page !== a && a > 0 && a <= c.totalPages && (d && d.target && d.target.blur(), b.ngModelCtrl.$setViewValue(a), b.ngModelCtrl.$render()); }, c.getText = function (a) { return c[`${a}Text`] || b.config[`${a}Text`]; }, c.noPrevious = function () { return c.page === 1; }, c.noNext = function () { return c.page === c.totalPages; }, b.updatePage = function () { b.setNumPages(c.$parent, c.totalPages), c.page > c.totalPages ? c.selectPage(c.totalPages) : b.ngModelCtrl.$render(); }, c.$on('$destroy', () => { for (;b._watchers.length;)b._watchers.shift()(); }); } }; }]), angular.module('ui.bootstrap.pager', ['ui.bootstrap.paging']).controller('UibPagerController', ['$scope', '$attrs', 'uibPaging', 'uibPagerConfig', function (a, b, c, d) { a.align = angular.isDefined(b.align) ? a.$parent.$eval(b.align) : d.align, c.create(this, a, b); }]).constant('uibPagerConfig', {
  itemsPerPage: 10, previousText: ' Previous', nextText: 'Next ', align: !0,
}).directive('uibPager', ['uibPagerConfig', function (a) {
  return {
    scope: {
      totalItems: '=', previousText: '@', nextText: '@', ngDisabled: '=',
    },
    require: ['uibPager', '?ngModel'],
    controller: 'UibPagerController',
    controllerAs: 'pager',
    templateUrl(a, b) { return b.templateUrl || 'uib/template/pager/pager.html'; },
    replace: !0,
    link(b, c, d, e) { const f = e[0]; const g = e[1]; g && f.init(g, a); },
  };
}]), angular.module('ui.bootstrap.pagination', ['ui.bootstrap.paging']).controller('UibPaginationController', ['$scope', '$attrs', '$parse', 'uibPaging', 'uibPaginationConfig', function (a, b, c, d, e) { function f(a, b, c) { return { number: a, text: b, active: c }; } function g(a, b) { const c = []; let d = 1; let e = b; const g = angular.isDefined(i) && b > i; g && (j ? (d = Math.max(a - Math.floor(i / 2), 1), e = d + i - 1, e > b && (e = b, d = e - i + 1)) : (d = (Math.ceil(a / i) - 1) * i + 1, e = Math.min(d + i - 1, b))); for (let h = d; e >= h; h++) { const m = f(h, h, h === a); c.push(m); } if (g && i > 0 && (!j || k || l)) { if (d > 1) { if (!l || d > 3) { const n = f(d - 1, '...', !1); c.unshift(n); } if (l) { if (d === 3) { const o = f(2, '2', !1); c.unshift(o); } const p = f(1, '1', !1); c.unshift(p); } } if (b > e) { if (!l || b - 2 > e) { const q = f(e + 1, '...', !1); c.push(q); } if (l) { if (e === b - 2) { const r = f(b - 1, b - 1, !1); c.push(r); } const s = f(b, b, !1); c.push(s); } } } return c; } const h = this; var i = angular.isDefined(b.maxSize) ? a.$parent.$eval(b.maxSize) : e.maxSize; var j = angular.isDefined(b.rotate) ? a.$parent.$eval(b.rotate) : e.rotate; var k = angular.isDefined(b.forceEllipses) ? a.$parent.$eval(b.forceEllipses) : e.forceEllipses; var l = angular.isDefined(b.boundaryLinkNumbers) ? a.$parent.$eval(b.boundaryLinkNumbers) : e.boundaryLinkNumbers; a.boundaryLinks = angular.isDefined(b.boundaryLinks) ? a.$parent.$eval(b.boundaryLinks) : e.boundaryLinks, a.directionLinks = angular.isDefined(b.directionLinks) ? a.$parent.$eval(b.directionLinks) : e.directionLinks, d.create(this, a, b), b.maxSize && h._watchers.push(a.$parent.$watch(c(b.maxSize), (a) => { i = parseInt(a, 10), h.render(); })); const m = this.render; this.render = function () { m(), a.page > 0 && a.page <= a.totalPages && (a.pages = g(a.page, a.totalPages)); }; }]).constant('uibPaginationConfig', {
  itemsPerPage: 10, boundaryLinks: !1, boundaryLinkNumbers: !1, directionLinks: !0, firstText: 'First', previousText: 'Previous', nextText: 'Next', lastText: 'Last', rotate: !0, forceEllipses: !1,
}).directive('uibPagination', ['$parse', 'uibPaginationConfig', function (a, b) {
  return {
    scope: {
      totalItems: '=', firstText: '@', previousText: '@', nextText: '@', lastText: '@', ngDisabled: '=',
    },
    require: ['uibPagination', '?ngModel'],
    controller: 'UibPaginationController',
    controllerAs: 'pagination',
    templateUrl(a, b) { return b.templateUrl || 'uib/template/pagination/pagination.html'; },
    replace: !0,
    link(a, c, d, e) { const f = e[0]; const g = e[1]; g && f.init(g, b); },
  };
}]), angular.module('ui.bootstrap.tooltip', ['ui.bootstrap.position', 'ui.bootstrap.stackedMap']).provider('$uibTooltip', function () {
  function a(a) { const b = /[A-Z]/g; const c = '-'; return a.replace(b, (a, b) => (b ? c : '') + a.toLowerCase()); } const b = {
    placement: 'top', placementClassPrefix: '', animation: !0, popupDelay: 0, popupCloseDelay: 0, useContentExp: !1,
  }; const c = {
    mouseenter: 'mouseleave', click: 'click', outsideClick: 'outsideClick', focus: 'blur', none: '',
  }; const d = {}; this.options = function (a) { angular.extend(d, a); }, this.setTriggers = function (a) { angular.extend(c, a); }, this.$get = ['$window', '$compile', '$timeout', '$document', '$uibPosition', '$interpolate', '$rootScope', '$parse', '$$stackedMap', function (e, f, g, h, i, j, k, l, m) { function n(a) { if (a.which === 27) { let b = o.top(); b && (b.value.close(), o.removeTop(), b = null); } } var o = m.createNew(); return h.on('keypress', n), k.$on('$destroy', () => { h.off('keypress', n); }), function (e, k, m, n) { function p(a) { const b = (a || n.trigger || m).split(' '); const d = b.map(a => c[a] || a); return { show: b, hide: d }; }n = angular.extend({}, b, d, n); const q = a(e); const r = j.startSymbol(); const s = j.endSymbol(); const t = `<div ${q}-popup title="${r}title${s}" ${n.useContentExp ? 'content-exp="contentExp()" ' : `content="${r}content${s}" `}placement="${r}placement${s}" popup-class="${r}popupClass${s}" animation="animation" is-open="isOpen"origin-scope="origScope" style="visibility: hidden; display: block; top: -9999px; left: -9999px;"></div>`; return { compile(a, b) { const c = f(t); return function (a, b, d, f) { function j() { M.isOpen ? q() : m(); } function m() { (!L || a.$eval(d[`${k}Enable`])) && (u(), x(), M.popupDelay ? G || (G = g(r, M.popupDelay, !1)) : r()); } function q() { s(), M.popupCloseDelay ? H || (H = g(t, M.popupCloseDelay, !1)) : t(); } function r() { return s(), u(), M.content ? (v(), void M.$evalAsync(() => { M.isOpen = !0, y(!0), R(); })) : angular.noop; } function s() { G && (g.cancel(G), G = null), I && (g.cancel(I), I = null); } function t() { M && M.$evalAsync(() => { M && (M.isOpen = !1, y(!1), M.animation ? F || (F = g(w, 150, !1)) : w()); }); } function u() { H && (g.cancel(H), H = null), F && (g.cancel(F), F = null); } function v() { D || (E = M.$new(), D = c(E, (a) => { J ? h.find('body').append(a) : b.after(a); }), z()); } function w() { s(), u(), A(), D && (D.remove(), D = null), E && (E.$destroy(), E = null); } function x() { M.title = d[`${k}Title`], P ? M.content = P(a) : M.content = d[e], M.popupClass = d[`${k}Class`], M.placement = angular.isDefined(d[`${k}Placement`]) ? d[`${k}Placement`] : n.placement; const b = parseInt(d[`${k}PopupDelay`], 10); const c = parseInt(d[`${k}PopupCloseDelay`], 10); M.popupDelay = isNaN(b) ? n.popupDelay : b, M.popupCloseDelay = isNaN(c) ? n.popupCloseDelay : c; } function y(b) { O && angular.isFunction(O.assign) && O.assign(a, b); } function z() { Q.length = 0, P ? (Q.push(a.$watch(P, (a) => { M.content = a, !a && M.isOpen && t(); })), Q.push(E.$watch(() => { N || (N = !0, E.$$postDigest(() => { N = !1, M && M.isOpen && R(); })); }))) : Q.push(d.$observe(e, (a) => { M.content = a, !a && M.isOpen ? t() : R(); })), Q.push(d.$observe(`${k}Title`, (a) => { M.title = a, M.isOpen && R(); })), Q.push(d.$observe(`${k}Placement`, (a) => { M.placement = a || n.placement, M.isOpen && R(); })); } function A() { Q.length && (angular.forEach(Q, (a) => { a(); }), Q.length = 0); } function B(a) { M && M.isOpen && D && (b[0].contains(a.target) || D[0].contains(a.target) || q()); } function C() { const a = d[`${k}Trigger`]; S(), K = p(a), K.show !== 'none' && K.show.forEach((a, c) => { a === 'outsideClick' ? (b.on('click', j), h.on('click', B)) : a === K.hide[c] ? b.on(a, j) : a && (b.on(a, m), b.on(K.hide[c], q)), b.on('keypress', (a) => { a.which === 27 && q(); }); }); } let D; let E; let F; let G; let H; let I; var J = angular.isDefined(n.appendToBody) ? n.appendToBody : !1; var K = p(void 0); var L = angular.isDefined(d[`${k}Enable`]); var M = a.$new(!0); var N = !1; var O = angular.isDefined(d[`${k}IsOpen`]) ? l(d[`${k}IsOpen`]) : !1; var P = n.useContentExp ? l(d[e]) : !1; var Q = []; var R = function () { D && D.html() && (I || (I = g(() => { D.css({ top: 0, left: 0 }); const a = i.positionElements(b, D, M.placement, J); D.css({ top: `${a.top}px`, left: `${a.left}px`, visibility: 'visible' }), n.placementClassPrefix && D.removeClass('top bottom left right'), D.removeClass(`${n.placementClassPrefix}top ${n.placementClassPrefix}top-left ${n.placementClassPrefix}top-right ${n.placementClassPrefix}bottom ${n.placementClassPrefix}bottom-left ${n.placementClassPrefix}bottom-right ${n.placementClassPrefix}left ${n.placementClassPrefix}left-top ${n.placementClassPrefix}left-bottom ${n.placementClassPrefix}right ${n.placementClassPrefix}right-top ${n.placementClassPrefix}right-bottom`); const c = a.placement.split('-'); D.addClass(`${c[0]} ${n.placementClassPrefix}${a.placement}`), i.positionArrow(D, a.placement), I = null; }, 0, !1))); }; M.origScope = a, M.isOpen = !1, o.add(M, { close: t }), M.contentExp = function () { return M.content; }, d.$observe('disabled', (a) => { a && s(), a && M.isOpen && t(); }), O && a.$watch(O, (a) => { M && !a === M.isOpen && j(); }); var S = function () { K.show.forEach((a) => { a === 'outsideClick' ? b.off('click', j) : (b.off(a, m), b.off(a, j)); }), K.hide.forEach((a) => { a === 'outsideClick' ? h.off('click', B) : b.off(a, q); }); }; C(); const T = a.$eval(d[`${k}Animation`]); M.animation = angular.isDefined(T) ? !!T : n.animation; let U; const V = `${k}AppendToBody`; U = V in d && void 0 === d[V] ? !0 : a.$eval(d[V]), J = angular.isDefined(U) ? U : J, J && a.$on('$locationChangeSuccess', () => { M.isOpen && t(); }), a.$on('$destroy', () => { S(), w(), o.remove(M), M = null; }); }; } }; }; }];
}).directive('uibTooltipTemplateTransclude', ['$animate', '$sce', '$compile', '$templateRequest', function (a, b, c, d) { return { link(e, f, g) { let h; let i; let j; const k = e.$eval(g.tooltipTemplateTranscludeScope); let l = 0; const m = function () { i && (i.remove(), i = null), h && (h.$destroy(), h = null), j && (a.leave(j).then(() => { i = null; }), i = j, j = null); }; e.$watch(b.parseAsResourceUrl(g.uibTooltipTemplateTransclude), (b) => { const g = ++l; b ? (d(b, !0).then((d) => { if (g === l) { const e = k.$new(); const i = d; const n = c(i)(e, (b) => { m(), a.enter(b, f); }); h = e, j = n, h.$emit('$includeContentLoaded', b); } }, () => { g === l && (m(), e.$emit('$includeContentError', b)); }), e.$emit('$includeContentRequested', b)) : m(); }), e.$on('$destroy', m); } }; }]).directive('uibTooltipClasses', ['$uibPosition', function (a) { return { restrict: 'A', link(b, c, d) { if (b.placement) { const e = a.parsePlacement(b.placement); c.addClass(e[0]); } else c.addClass('top'); b.popupClass && c.addClass(b.popupClass), b.animation() && c.addClass(d.tooltipAnimationClass); } }; }])
  .directive('uibTooltipPopup', () => ({
    replace: !0,
    scope: {
      content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&',
    },
    templateUrl: 'uib/template/tooltip/tooltip-popup.html',
  }))
  .directive('uibTooltip', ['$uibTooltip', function (a) { return a('uibTooltip', 'tooltip', 'mouseenter'); }])
  .directive('uibTooltipTemplatePopup', () => ({
    replace: !0,
    scope: {
      contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&', originScope: '&',
    },
    templateUrl: 'uib/template/tooltip/tooltip-template-popup.html',
  }))
  .directive('uibTooltipTemplate', ['$uibTooltip', function (a) { return a('uibTooltipTemplate', 'tooltip', 'mouseenter', { useContentExp: !0 }); }])
  .directive('uibTooltipHtmlPopup', () => ({
    replace: !0,
    scope: {
      contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',
    },
    templateUrl: 'uib/template/tooltip/tooltip-html-popup.html',
  }))
  .directive('uibTooltipHtml', ['$uibTooltip', function (a) { return a('uibTooltipHtml', 'tooltip', 'mouseenter', { useContentExp: !0 }); }]), angular.module('ui.bootstrap.popover', ['ui.bootstrap.tooltip']).directive('uibPopoverTemplatePopup', () => ({
  replace: !0,
  scope: {
    title: '@', contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&', originScope: '&',
  },
  templateUrl: 'uib/template/popover/popover-template.html',
})).directive('uibPopoverTemplate', ['$uibTooltip', function (a) {
  return a('uibPopoverTemplate', 'popover', 'click', { useContentExp: !0 });
}]).directive('uibPopoverHtmlPopup', () => ({
  replace: !0,
  scope: {
    contentExp: '&', title: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&',
  },
  templateUrl: 'uib/template/popover/popover-html.html',
}))
  .directive('uibPopoverHtml', ['$uibTooltip', function (a) { return a('uibPopoverHtml', 'popover', 'click', { useContentExp: !0 }); }])
  .directive('uibPopoverPopup', () => ({
    replace: !0,
    scope: {
      title: '@', content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&',
    },
    templateUrl: 'uib/template/popover/popover.html',
  }))
  .directive('uibPopover', ['$uibTooltip', function (a) { return a('uibPopover', 'popover', 'click'); }]), angular.module('ui.bootstrap.progressbar', []).constant('uibProgressConfig', { animate: !0, max: 100 }).controller('UibProgressController', ['$scope', '$attrs', 'uibProgressConfig', function (a, b, c) { const d = this; const e = angular.isDefined(b.animate) ? a.$parent.$eval(b.animate) : c.animate; this.bars = [], a.max = angular.isDefined(a.max) ? a.max : c.max, this.addBar = function (b, c, f) { e || c.css({ transition: 'none' }), this.bars.push(b), b.max = a.max, b.title = f && angular.isDefined(f.title) ? f.title : 'progressbar', b.$watch('value', (a) => { b.recalculatePercentage(); }), b.recalculatePercentage = function () { const a = d.bars.reduce((a, b) => b.percent = +(100 * b.value / b.max).toFixed(2), a + b.percent, 0); a > 100 && (b.percent -= a - 100); }, b.$on('$destroy', () => { c = null, d.removeBar(b); }); }, this.removeBar = function (a) { this.bars.splice(this.bars.indexOf(a), 1), this.bars.forEach((a) => { a.recalculatePercentage(); }); }, a.$watch('max', (b) => { d.bars.forEach((b) => { b.max = a.max, b.recalculatePercentage(); }); }); }]).directive('uibProgress', () => ({
  replace: !0, transclude: !0, controller: 'UibProgressController', require: 'uibProgress', scope: { max: '=?' }, templateUrl: 'uib/template/progressbar/progress.html',
}))
  .directive('uibBar', () => ({
    replace: !0, transclude: !0, require: '^uibProgress', scope: { value: '=', type: '@' }, templateUrl: 'uib/template/progressbar/bar.html', link(a, b, c, d) { d.addBar(a, b, c); },
  }))
  .directive('uibProgressbar', () => ({
    replace: !0, transclude: !0, controller: 'UibProgressController', scope: { value: '=', max: '=?', type: '@' }, templateUrl: 'uib/template/progressbar/progressbar.html', link(a, b, c, d) { d.addBar(a, angular.element(b.children()[0]), { title: c.title }); },
  })), angular.module('ui.bootstrap.rating', []).constant('uibRatingConfig', {
  max: 5, stateOn: null, stateOff: null, titles: ['one', 'two', 'three', 'four', 'five'],
}).controller('UibRatingController', ['$scope', '$attrs', 'uibRatingConfig', function (a, b, c) { let d = { $setViewValue: angular.noop }; this.init = function (e) { d = e, d.$render = this.render, d.$formatters.push(a => angular.isNumber(a) && a << 0 !== a && (a = Math.round(a)), a), this.stateOn = angular.isDefined(b.stateOn) ? a.$parent.$eval(b.stateOn) : c.stateOn, this.stateOff = angular.isDefined(b.stateOff) ? a.$parent.$eval(b.stateOff) : c.stateOff; const f = angular.isDefined(b.titles) ? a.$parent.$eval(b.titles) : c.titles; this.titles = angular.isArray(f) && f.length > 0 ? f : c.titles; const g = angular.isDefined(b.ratingStates) ? a.$parent.$eval(b.ratingStates) : new Array(angular.isDefined(b.max) ? a.$parent.$eval(b.max) : c.max); a.range = this.buildTemplateObjects(g); }, this.buildTemplateObjects = function (a) { for (let b = 0, c = a.length; c > b; b++)a[b] = angular.extend({ index: b }, { stateOn: this.stateOn, stateOff: this.stateOff, title: this.getTitle(b) }, a[b]); return a; }, this.getTitle = function (a) { return a >= this.titles.length ? a + 1 : this.titles[a]; }, a.rate = function (b) { !a.readonly && b >= 0 && b <= a.range.length && (d.$setViewValue(d.$viewValue === b ? 0 : b), d.$render()); }, a.enter = function (b) { a.readonly || (a.value = b), a.onHover({ value: b }); }, a.reset = function () { a.value = d.$viewValue, a.onLeave(); }, a.onKeydown = function (b) { /(37|38|39|40)/.test(b.which) && (b.preventDefault(), b.stopPropagation(), a.rate(a.value + (b.which === 38 || b.which === 39 ? 1 : -1))); }, this.render = function () { a.value = d.$viewValue; }; }]).directive('uibRating', () => ({
  require: ['uibRating', 'ngModel'], scope: { readonly: '=?', onHover: '&', onLeave: '&' }, controller: 'UibRatingController', templateUrl: 'uib/template/rating/rating.html', replace: !0, link(a, b, c, d) { const e = d[0]; const f = d[1]; e.init(f); },
})), angular.module('ui.bootstrap.tabs', []).controller('UibTabsetController', ['$scope', function (a) { const b = this; const c = b.tabs = a.tabs = []; b.select = function (a) { angular.forEach(c, (b) => { b.active && b !== a && (b.active = !1, b.onDeselect(), a.selectCalled = !1); }), a.active = !0, a.selectCalled || (a.onSelect(), a.selectCalled = !0); }, b.addTab = function (a) { c.push(a), c.length === 1 && a.active !== !1 ? a.active = !0 : a.active ? b.select(a) : a.active = !1; }, b.removeTab = function (a) { const e = c.indexOf(a); if (a.active && c.length > 1 && !d) { const f = e === c.length - 1 ? e - 1 : e + 1; b.select(c[f]); }c.splice(e, 1); }; let d; a.$on('$destroy', () => { d = !0; }); }]).directive('uibTabset', () => ({
  transclude: !0, replace: !0, scope: { type: '@' }, controller: 'UibTabsetController', templateUrl: 'uib/template/tabs/tabset.html', link(a, b, c) { a.vertical = angular.isDefined(c.vertical) ? a.$parent.$eval(c.vertical) : !1, a.justified = angular.isDefined(c.justified) ? a.$parent.$eval(c.justified) : !1; },
})).directive('uibTab', ['$parse', function (a) {
  return {
    require: '^uibTabset',
    replace: !0,
    templateUrl: 'uib/template/tabs/tab.html',
    transclude: !0,
    scope: {
      active: '=?', heading: '@', onSelect: '&select', onDeselect: '&deselect',
    },
    controller() {},
    controllerAs: 'tab',
    link(b, c, d, e, f) { b.$watch('active', (a) => { a && e.select(b); }), b.disabled = !1, d.disable && b.$parent.$watch(a(d.disable), (a) => { b.disabled = !!a; }), b.select = function () { b.disabled || (b.active = !0); }, e.addTab(b), b.$on('$destroy', () => { e.removeTab(b); }), b.$transcludeFn = f; },
  };
}])
  .directive('uibTabHeadingTransclude', () => ({ restrict: 'A', require: '^uibTab', link(a, b) { a.$watch('headingElement', (a) => { a && (b.html(''), b.append(a)); }); } }))
  .directive('uibTabContentTransclude', () => { function a(a) { return a.tagName && (a.hasAttribute('uib-tab-heading') || a.hasAttribute('data-uib-tab-heading') || a.hasAttribute('x-uib-tab-heading') || a.tagName.toLowerCase() === 'uib-tab-heading' || a.tagName.toLowerCase() === 'data-uib-tab-heading' || a.tagName.toLowerCase() === 'x-uib-tab-heading'); } return { restrict: 'A', require: '^uibTabset', link(b, c, d) { const e = b.$eval(d.uibTabContentTransclude); e.$transcludeFn(e.$parent, (b) => { angular.forEach(b, (b) => { a(b) ? e.headingElement = b : c.append(b); }); }); } }; }), angular.module('ui.bootstrap.timepicker', []).constant('uibTimepickerConfig', {
  hourStep: 1, minuteStep: 1, secondStep: 1, showMeridian: !0, showSeconds: !1, meridians: null, readonlyInput: !1, mousewheel: !0, arrowkeys: !0, showSpinners: !0, templateUrl: 'uib/template/timepicker/timepicker.html',
}).controller('UibTimepickerController', ['$scope', '$element', '$attrs', '$parse', '$log', '$locale', 'uibTimepickerConfig', function (a, b, c, d, e, f, g) {
  function h() { let b = +a.hours; const c = a.showMeridian ? b > 0 && b < 13 : b >= 0 && b < 24; return c ? (a.showMeridian && (b === 12 && (b = 0), a.meridian === u[1] && (b += 12)), b) : void 0; } function i() { const b = +a.minutes; return b >= 0 && b < 60 ? b : void 0; } function j() { const b = +a.seconds; return b >= 0 && b < 60 ? b : void 0; } function k(a) { return a === null ? '' : angular.isDefined(a) && a.toString().length < 2 ? `0${a}` : a.toString(); } function l(a) { m(), t.$setViewValue(new Date(r)), n(a); } function m() { t.$setValidity('time', !0), a.invalidHours = !1, a.invalidMinutes = !1, a.invalidSeconds = !1; } function n(b) { if (t.$modelValue) { let c = r.getHours(); const d = r.getMinutes(); const e = r.getSeconds(); a.showMeridian && (c = c === 0 || c === 12 ? 12 : c % 12), a.hours = b === 'h' ? c : k(c), b !== 'm' && (a.minutes = k(d)), a.meridian = r.getHours() < 12 ? u[0] : u[1], b !== 's' && (a.seconds = k(e)), a.meridian = r.getHours() < 12 ? u[0] : u[1]; } else a.hours = null, a.minutes = null, a.seconds = null, a.meridian = u[0]; } function o(a) { r = q(r, a), l(); } function p(a, b) { return q(a, 60 * b); } function q(a, b) { const c = new Date(a.getTime() + 1e3 * b); const d = new Date(a); return d.setHours(c.getHours(), c.getMinutes(), c.getSeconds()), d; } var r = new Date();
  const s = [];
  var t = { $setViewValue: angular.noop };
  var u = angular.isDefined(c.meridians) ? a.$parent.$eval(c.meridians) : g.meridians || f.DATETIME_FORMATS.AMPMS; a.tabindex = angular.isDefined(c.tabindex) ? c.tabindex : 0, b.removeAttr('tabindex'), this.init = function (b, d) { t = b, t.$render = this.render, t.$formatters.unshift(a => (a ? new Date(a) : null)); const e = d.eq(0); const f = d.eq(1); const h = d.eq(2); const i = angular.isDefined(c.mousewheel) ? a.$parent.$eval(c.mousewheel) : g.mousewheel; i && this.setupMousewheelEvents(e, f, h); const j = angular.isDefined(c.arrowkeys) ? a.$parent.$eval(c.arrowkeys) : g.arrowkeys; j && this.setupArrowkeyEvents(e, f, h), a.readonlyInput = angular.isDefined(c.readonlyInput) ? a.$parent.$eval(c.readonlyInput) : g.readonlyInput, this.setupInputEvents(e, f, h); }; let v = g.hourStep; c.hourStep && s.push(a.$parent.$watch(d(c.hourStep), (a) => { v = +a; })); let w = g.minuteStep; c.minuteStep && s.push(a.$parent.$watch(d(c.minuteStep), (a) => { w = +a; })); let x; s.push(a.$parent.$watch(d(c.min), (a) => { const b = new Date(a); x = isNaN(b) ? void 0 : b; })); let y; s.push(a.$parent.$watch(d(c.max), (a) => { const b = new Date(a); y = isNaN(b) ? void 0 : b; })); let z = !1; c.ngDisabled && s.push(a.$parent.$watch(d(c.ngDisabled), (a) => { z = a; })), a.noIncrementHours = function () { const a = p(r, 60 * v); return z || a > y || r > a && x > a; }, a.noDecrementHours = function () { const a = p(r, 60 * -v); return z || x > a || a > r && a > y; }, a.noIncrementMinutes = function () { const a = p(r, w); return z || a > y || r > a && x > a; }, a.noDecrementMinutes = function () { const a = p(r, -w); return z || x > a || a > r && a > y; }, a.noIncrementSeconds = function () { const a = q(r, A); return z || a > y || r > a && x > a; }, a.noDecrementSeconds = function () { const a = q(r, -A); return z || x > a || a > r && a > y; }, a.noToggleMeridian = function () { return r.getHours() < 12 ? z || p(r, 720) > y : z || p(r, -720) < x; }; var A = g.secondStep; c.secondStep && s.push(a.$parent.$watch(d(c.secondStep), (a) => { A = +a; })), a.showSeconds = g.showSeconds, c.showSeconds && s.push(a.$parent.$watch(d(c.showSeconds), (b) => { a.showSeconds = !!b; })), a.showMeridian = g.showMeridian, c.showMeridian && s.push(a.$parent.$watch(d(c.showMeridian), (b) => { if (a.showMeridian = !!b, t.$error.time) { const c = h(); const d = i(); angular.isDefined(c) && angular.isDefined(d) && (r.setHours(c), l()); } else n(); })), this.setupMousewheelEvents = function (b, c, d) { const e = function (a) { a.originalEvent && (a = a.originalEvent); const b = a.wheelDelta ? a.wheelDelta : -a.deltaY; return a.detail || b > 0; }; b.bind('mousewheel wheel', (b) => { z || a.$apply(e(b) ? a.incrementHours() : a.decrementHours()), b.preventDefault(); }), c.bind('mousewheel wheel', (b) => { z || a.$apply(e(b) ? a.incrementMinutes() : a.decrementMinutes()), b.preventDefault(); }), d.bind('mousewheel wheel', (b) => { z || a.$apply(e(b) ? a.incrementSeconds() : a.decrementSeconds()), b.preventDefault(); }); }, this.setupArrowkeyEvents = function (b, c, d) { b.bind('keydown', (b) => { z || (b.which === 38 ? (b.preventDefault(), a.incrementHours(), a.$apply()) : b.which === 40 && (b.preventDefault(), a.decrementHours(), a.$apply())); }), c.bind('keydown', (b) => { z || (b.which === 38 ? (b.preventDefault(), a.incrementMinutes(), a.$apply()) : b.which === 40 && (b.preventDefault(), a.decrementMinutes(), a.$apply())); }), d.bind('keydown', (b) => { z || (b.which === 38 ? (b.preventDefault(), a.incrementSeconds(), a.$apply()) : b.which === 40 && (b.preventDefault(), a.decrementSeconds(), a.$apply())); }); }, this.setupInputEvents = function (b, c, d) { if (a.readonlyInput) return a.updateHours = angular.noop, a.updateMinutes = angular.noop, void (a.updateSeconds = angular.noop); const e = function (b, c, d) { t.$setViewValue(null), t.$setValidity('time', !1), angular.isDefined(b) && (a.invalidHours = b), angular.isDefined(c) && (a.invalidMinutes = c), angular.isDefined(d) && (a.invalidSeconds = d); }; a.updateHours = function () { const a = h(); const b = i(); t.$setDirty(), angular.isDefined(a) && angular.isDefined(b) ? (r.setHours(a), r.setMinutes(b), x > r || r > y ? e(!0) : l('h')) : e(!0); }, b.bind('blur', (b) => { t.$setTouched(), a.hours === null || a.hours === '' ? e(!0) : !a.invalidHours && a.hours < 10 && a.$apply(() => { a.hours = k(a.hours); }); }), a.updateMinutes = function () { const a = i(); const b = h(); t.$setDirty(), angular.isDefined(a) && angular.isDefined(b) ? (r.setHours(b), r.setMinutes(a), x > r || r > y ? e(void 0, !0) : l('m')) : e(void 0, !0); }, c.bind('blur', (b) => { t.$setTouched(), a.minutes === null ? e(void 0, !0) : !a.invalidMinutes && a.minutes < 10 && a.$apply(() => { a.minutes = k(a.minutes); }); }), a.updateSeconds = function () { const a = j(); t.$setDirty(), angular.isDefined(a) ? (r.setSeconds(a), l('s')) : e(void 0, void 0, !0); }, d.bind('blur', (b) => { !a.invalidSeconds && a.seconds < 10 && a.$apply(() => { a.seconds = k(a.seconds); }); }); }, this.render = function () { const b = t.$viewValue; isNaN(b) ? (t.$setValidity('time', !1), e.error('Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.')) : (b && (r = b), x > r || r > y ? (t.$setValidity('time', !1), a.invalidHours = !0, a.invalidMinutes = !0) : m(), n()); }, a.showSpinners = angular.isDefined(c.showSpinners) ? a.$parent.$eval(c.showSpinners) : g.showSpinners, a.incrementHours = function () { a.noIncrementHours() || o(60 * v * 60); }, a.decrementHours = function () { a.noDecrementHours() || o(60 * -v * 60); }, a.incrementMinutes = function () { a.noIncrementMinutes() || o(60 * w); }, a.decrementMinutes = function () { a.noDecrementMinutes() || o(60 * -w); }, a.incrementSeconds = function () { a.noIncrementSeconds() || o(A); }, a.decrementSeconds = function () { a.noDecrementSeconds() || o(-A); }, a.toggleMeridian = function () { const b = i(); const c = h(); a.noToggleMeridian() || (angular.isDefined(b) && angular.isDefined(c) ? o(720 * (r.getHours() < 12 ? 60 : -60)) : a.meridian = a.meridian === u[0] ? u[1] : u[0]); }, a.blur = function () { t.$setTouched(); }, a.$on('$destroy', () => { for (;s.length;)s.shift()(); });
}]).directive('uibTimepicker', ['uibTimepickerConfig', function (a) {
  return {
    require: ['uibTimepicker', '?^ngModel'], controller: 'UibTimepickerController', controllerAs: 'timepicker', replace: !0, scope: {}, templateUrl(b, c) { return c.templateUrl || a.templateUrl; }, link(a, b, c, d) { const e = d[0]; const f = d[1]; f && e.init(f, b.find('input')); },
  };
}]), angular.module('ui.bootstrap.typeahead', ['ui.bootstrap.debounce', 'ui.bootstrap.position']).factory('uibTypeaheadParser', ['$parse', function (a) {
  const b = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+([\s\S]+?)$/; return {
    parse(c) {
      const d = c.match(b); if (!d) throw new Error(`Expected typeahead specification in form of "_modelValue_ (as _label_)? for _item_ in _collection_" but got "${c}".`); return {
        itemName: d[3], source: a(d[4]), viewMapper: a(d[2] || d[1]), modelMapper: a(d[1]),
      };
    },
  };
}]).controller('UibTypeaheadController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$q', '$timeout', '$document', '$window', '$rootScope', '$$debounce', '$uibPosition', 'uibTypeaheadParser', function (a, b, c, d, e, f, g, h, i, j, k, l, m) {
  function n() { N.moveInProgress || (N.moveInProgress = !0, N.$digest()), Y(); } function o() { N.position = D ? l.offset(b) : l.position(b), N.position.top += b.prop('offsetHeight'); } let p; let q; const r = [9, 13, 27, 38, 40]; const s = 200; let t = a.$eval(c.typeaheadMinLength); t || t === 0 || (t = 1); const u = a.$eval(c.typeaheadWaitMs) || 0; let v = a.$eval(c.typeaheadEditable) !== !1; a.$watch(c.typeaheadEditable, (a) => { v = a !== !1; }); let w; let x; const y = e(c.typeaheadLoading).assign || angular.noop; const z = e(c.typeaheadOnSelect); const A = angular.isDefined(c.typeaheadSelectOnBlur) ? a.$eval(c.typeaheadSelectOnBlur) : !1; const B = e(c.typeaheadNoResults).assign || angular.noop; const C = c.typeaheadInputFormatter ? e(c.typeaheadInputFormatter) : void 0; var D = c.typeaheadAppendToBody ? a.$eval(c.typeaheadAppendToBody) : !1; const E = c.typeaheadAppendTo ? a.$eval(c.typeaheadAppendTo) : null; const F = a.$eval(c.typeaheadFocusFirst) !== !1; const G = c.typeaheadSelectOnExact ? a.$eval(c.typeaheadSelectOnExact) : !1; const H = e(c.typeaheadIsOpen).assign || angular.noop; const I = a.$eval(c.typeaheadShowHint) || !1; const J = e(c.ngModel); const K = e(`${c.ngModel}($$$p)`); const L = function (b, c) { return angular.isFunction(J(a)) && q && q.$options && q.$options.getterSetter ? K(b, { $$$p: c }) : J.assign(b, c); }; const M = m.parse(c.uibTypeahead); var N = a.$new(); const O = a.$on('$destroy', () => { N.$destroy(); }); N.$on('$destroy', O); const P = `typeahead-${N.$id}-${Math.floor(1e4 * Math.random())}`; b.attr({ 'aria-autocomplete': 'list', 'aria-expanded': !1, 'aria-owns': P }); let Q; let R; I && (Q = angular.element('<div></div>'), Q.css('position', 'relative'), b.after(Q), R = b.clone(), R.attr('placeholder', ''), R.val(''), R.css({
    position: 'absolute', top: '0px', left: '0px', 'border-color': 'transparent', 'box-shadow': 'none', opacity: 1, background: 'none 0% 0% / auto repeat scroll padding-box border-box rgb(255, 255, 255)', color: '#999',
  }), b.css({ position: 'relative', 'vertical-align': 'top', 'background-color': 'transparent' }), Q.append(R), R.after(b)); const S = angular.element('<div uib-typeahead-popup></div>'); S.attr({
    id: P, matches: 'matches', active: 'activeIdx', select: 'select(activeIdx, evt)', 'move-in-progress': 'moveInProgress', query: 'query', position: 'position', 'assign-is-open': 'assignIsOpen(isOpen)', debounce: 'debounceUpdate',
  }), angular.isDefined(c.typeaheadTemplateUrl) && S.attr('template-url', c.typeaheadTemplateUrl), angular.isDefined(c.typeaheadPopupTemplateUrl) && S.attr('popup-template-url', c.typeaheadPopupTemplateUrl); const T = function () { I && R.val(''); }; const U = function () { N.matches = [], N.activeIdx = -1, b.attr('aria-expanded', !1), T(); }; const V = function (a) { return `${P}-option-${a}`; }; N.$watch('activeIdx', (a) => { a < 0 ? b.removeAttr('aria-activedescendant') : b.attr('aria-activedescendant', V(a)); }); const W = function (a, b) { return N.matches.length > b && a ? a.toUpperCase() === N.matches[b].label.toUpperCase() : !1; }; const X = function (c, d) { const e = { $viewValue: c }; y(a, !0), B(a, !1), f.when(M.source(a, e)).then((f) => { const g = c === p.$viewValue; if (g && w) if (f && f.length > 0) { N.activeIdx = F ? 0 : -1, B(a, !1), N.matches.length = 0; for (let h = 0; h < f.length; h++)e[M.itemName] = f[h], N.matches.push({ id: V(h), label: M.viewMapper(N, e), model: f[h] }); if (N.query = c, o(), b.attr('aria-expanded', !0), G && N.matches.length === 1 && W(c, 0) && (angular.isNumber(N.debounceUpdate) || angular.isObject(N.debounceUpdate) ? k(() => { N.select(0, d); }, angular.isNumber(N.debounceUpdate) ? N.debounceUpdate : N.debounceUpdate.default) : N.select(0, d)), I) { const i = N.matches[0].label; c.length > 0 && i.slice(0, c.length).toUpperCase() === c.toUpperCase() ? R.val(c + i.slice(c.length)) : R.val(''); } } else U(), B(a, !0); g && y(a, !1); }, () => { U(), y(a, !1), B(a, !0); }); }; D && (angular.element(i).on('resize', n), h.find('body').on('scroll', n)); var Y = k(() => { N.matches.length && o(), N.moveInProgress = !1; }, s); N.moveInProgress = !1, N.query = void 0; let Z; const $ = function (a) { Z = g(() => { X(a); }, u); }; const _ = function () { Z && g.cancel(Z); }; U(), N.assignIsOpen = function (b) { H(a, b); }, N.select = function (d, e) {
    let f; let h; const i = {}; x = !0, i[M.itemName] = h = N.matches[d].model, f = M.modelMapper(a, i), L(a, f), p.$setValidity('editable', !0), p.$setValidity('parse', !0), z(a, {
      $item: h, $model: f, $label: M.viewMapper(a, i), $event: e,
    }), U(), N.$eval(c.typeaheadFocusOnSelect) !== !1 && g(() => { b[0].focus(); }, 0, !1);
  }, b.on('keydown', (a) => { if (N.matches.length !== 0 && r.indexOf(a.which) !== -1) { if (N.activeIdx === -1 && (a.which === 9 || a.which === 13)) return U(), void N.$digest(); a.preventDefault(); let b; switch (a.which) { case 9: case 13: N.$apply(() => { angular.isNumber(N.debounceUpdate) || angular.isObject(N.debounceUpdate) ? k(() => { N.select(N.activeIdx, a); }, angular.isNumber(N.debounceUpdate) ? N.debounceUpdate : N.debounceUpdate.default) : N.select(N.activeIdx, a); }); break; case 27: a.stopPropagation(), U(), N.$digest(); break; case 38: N.activeIdx = (N.activeIdx > 0 ? N.activeIdx : N.matches.length) - 1, N.$digest(), b = S.find('li')[N.activeIdx], b.parentNode.scrollTop = b.offsetTop; break; case 40: N.activeIdx = (N.activeIdx + 1) % N.matches.length, N.$digest(), b = S.find('li')[N.activeIdx], b.parentNode.scrollTop = b.offsetTop; } } }), b.bind('focus', (a) => { w = !0, t !== 0 || p.$viewValue || g(() => { X(p.$viewValue, a); }, 0); }), b.bind('blur', (a) => { A && N.matches.length && N.activeIdx !== -1 && !x && (x = !0, N.$apply(() => { angular.isObject(N.debounceUpdate) && angular.isNumber(N.debounceUpdate.blur) ? k(() => { N.select(N.activeIdx, a); }, N.debounceUpdate.blur) : N.select(N.activeIdx, a); })), !v && p.$error.editable && (p.$viewValue = '', b.val('')), w = !1, x = !1; }); const aa = function (a) { b[0] !== a.target && a.which !== 3 && N.matches.length !== 0 && (U(), j.$$phase || N.$digest()); }; h.on('click', aa), a.$on('$destroy', () => { h.off('click', aa), (D || E) && ba.remove(), D && (angular.element(i).off('resize', n), h.find('body').off('scroll', n)), S.remove(), I && Q.remove(); }); var ba = d(S)(N); D ? h.find('body').append(ba) : E ? angular.element(E).eq(0).append(ba) : b.after(ba), this.init = function (b, c) { p = b, q = c, N.debounceUpdate = p.$options && e(p.$options.debounce)(a), p.$parsers.unshift(b => w = !0, t === 0 || b && b.length >= t ? u > 0 ? (_(), $(b)) : X(b) : (y(a, !1), _(), U()), v ? b : b ? void p.$setValidity('editable', !1) : (p.$setValidity('editable', !0), null)), p.$formatters.push((b) => { let c; let d; const e = {}; return v || p.$setValidity('editable', !0), C ? (e.$model = b, C(a, e)) : (e[M.itemName] = b, c = M.viewMapper(a, e), e[M.itemName] = void 0, d = M.viewMapper(a, e), c !== d ? c : b); }); };
}]).directive('uibTypeahead', () => ({ controller: 'UibTypeaheadController', require: ['ngModel', '^?ngModelOptions', 'uibTypeahead'], link(a, b, c, d) { d[2].init(d[0], d[1]); } }))
  .directive('uibTypeaheadPopup', ['$$debounce', function (a) {
    return {
      scope: {
        matches: '=', query: '=', active: '=', position: '&', moveInProgress: '=', select: '&', assignIsOpen: '&', debounce: '&',
      },
      replace: !0,
      templateUrl(a, b) { return b.popupTemplateUrl || 'uib/template/typeahead/typeahead-popup.html'; },
      link(b, c, d) { b.templateUrl = d.templateUrl, b.isOpen = function () { const a = b.matches.length > 0; return b.assignIsOpen({ isOpen: a }), a; }, b.isActive = function (a) { return b.active === a; }, b.selectActive = function (a) { b.active = a; }, b.selectMatch = function (c, d) { const e = b.debounce(); angular.isNumber(e) || angular.isObject(e) ? a(() => { b.select({ activeIdx: c, evt: d }); }, angular.isNumber(e) ? e : e.default) : b.select({ activeIdx: c, evt: d }); }; },
    };
  }])
  .directive('uibTypeaheadMatch', ['$templateRequest', '$compile', '$parse', function (a, b, c) { return { scope: { index: '=', match: '=', query: '=' }, link(d, e, f) { const g = c(f.templateUrl)(d.$parent) || 'uib/template/typeahead/typeahead-match.html'; a(g).then((a) => { const c = angular.element(a.trim()); e.replaceWith(c), b(c)(d); }); } }; }])
  .filter('uibTypeaheadHighlight', ['$sce', '$injector', '$log', function (a, b, c) { function d(a) { return a.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1'); } function e(a) { return /<.*>/g.test(a); } let f; return f = b.has('$sanitize'), function (b, g) { return !f && e(b) && c.warn('Unsafe use of typeahead please use ngSanitize'), b = g ? (`${b}`).replace(new RegExp(d(g), 'gi'), '<strong>$&</strong>') : b, f || (b = a.trustAsHtml(b)), b; }; }]), angular.module('ui.bootstrap.carousel').run(() => { !angular.$$csp().noInlineStyle && angular.element(document).find('head').prepend('<style type="text/css">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>'); }), angular.module('ui.bootstrap.datepicker').run(() => { !angular.$$csp().noInlineStyle && angular.element(document).find('head').prepend('<style type="text/css">.uib-datepicker .uib-title{width:100%;}.uib-day button,.uib-month button,.uib-year button{min-width:100%;}.uib-datepicker-popup.dropdown-menu{display:block;}.uib-button-bar{padding:10px 9px 2px;}</style>'); }), angular.module('ui.bootstrap.timepicker').run(() => { !angular.$$csp().noInlineStyle && angular.element(document).find('head').prepend('<style type="text/css">.uib-time input{width:50px;}</style>'); }), angular.module('ui.bootstrap.typeahead').run(() => { !angular.$$csp().noInlineStyle && angular.element(document).find('head').prepend('<style type="text/css">[uib-typeahead-popup].dropdown-menu{display:block;}</style>'); });
